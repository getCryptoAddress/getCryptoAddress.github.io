import{e as tt,a0 as rn,f as P,g as ct,j as qe,u as _n,k as ae,m as Hn,n as Dn,o as $,au as Dr,bE as Uo,i as Vt,M as Lo,O as Ro,l as Wr,aj as No,R as Co,K as _o,bF as Ho,Q as Do,ak as Wo,bG as Vo}from"./index-0ac701b5.js";const Ko=tt("divider",`
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`,[rn("vertical",`
 margin-top: 24px;
 margin-bottom: 24px;
 `,[rn("no-title",`
 display: flex;
 align-items: center;
 `)]),P("title",`
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `),ct("title-position-left",[P("line",[ct("left",{width:"28px"})])]),ct("title-position-right",[P("line",[ct("right",{width:"28px"})])]),ct("dashed",[P("line",`
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]),ct("vertical",`
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `),P("line",`
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `),rn("dashed",[P("line",{backgroundColor:"var(--n-color)"})]),ct("dashed",[P("line",{borderColor:"var(--n-color)"})]),ct("vertical",{backgroundColor:"var(--n-color)"})]),Po=Object.assign(Object.assign({},ae.props),{titlePlacement:{type:String,default:"center"},dashed:Boolean,vertical:Boolean}),Ec=qe({name:"Divider",props:Po,setup(t){const{mergedClsPrefixRef:e,inlineThemeDisabled:n}=_n(t),r=ae("Divider","-divider",Ko,Uo,t,e),o=Hn(()=>{const{common:{cubicBezierEaseInOut:s},self:{color:c,textColor:a,fontWeight:f}}=r.value;return{"--n-bezier":s,"--n-color":c,"--n-text-color":a,"--n-font-weight":f}}),i=n?Dn("divider",void 0,o,t):void 0;return{mergedClsPrefix:e,cssVars:n?void 0:o,themeClass:i?.themeClass,onRender:i?.onRender}},render(){var t;const{$slots:e,titlePlacement:n,vertical:r,dashed:o,cssVars:i,mergedClsPrefix:s}=this;return(t=this.onRender)===null||t===void 0||t.call(this),$("div",{role:"separator",class:[`${s}-divider`,this.themeClass,{[`${s}-divider--vertical`]:r,[`${s}-divider--no-title`]:!e.default,[`${s}-divider--dashed`]:o,[`${s}-divider--title-position-${n}`]:e.default&&n}],style:i},r?null:$("div",{class:`${s}-divider__line ${s}-divider__line--left`}),!r&&e.default?$(Dr,null,$("div",{class:`${s}-divider__title`},this.$slots),$("div",{class:`${s}-divider__line ${s}-divider__line--right`})):null)}}),qo=Vt([tt("list",`
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `,[ct("show-divider",[tt("list-item",[Vt("&:not(:last-child)",[P("divider",`
 background-color: var(--n-merged-border-color);
 `)])])]),ct("clickable",[tt("list-item",`
 cursor: pointer;
 `)]),ct("bordered",`
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `),ct("hoverable",[tt("list-item",`
 border-radius: var(--n-border-radius);
 `,[Vt("&:hover",`
 background-color: var(--n-merged-color-hover);
 `,[P("divider",`
 background-color: transparent;
 `)])])]),ct("bordered, hoverable",[tt("list-item",`
 padding: 12px 20px;
 `),P("header, footer",`
 padding: 12px 20px;
 `)]),P("header, footer",`
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `,[Vt("&:not(:last-child)",`
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]),tt("list-item",`
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `,[P("prefix",`
 margin-right: 20px;
 flex: 0;
 `),P("suffix",`
 margin-left: 20px;
 flex: 0;
 `),P("main",`
 flex: 1;
 `),P("divider",`
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]),Lo(tt("list",`
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)),Ro(tt("list",`
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]),zo=Object.assign(Object.assign({},ae.props),{size:{type:String,default:"medium"},bordered:Boolean,clickable:Boolean,hoverable:Boolean,showDivider:{type:Boolean,default:!0}}),Vr=_o("n-list"),xc=qe({name:"List",props:zo,setup(t){const{mergedClsPrefixRef:e,inlineThemeDisabled:n,mergedRtlRef:r}=_n(t),o=Wr("List",r,e),i=ae("List","-list",qo,Ho,t,e);No(Vr,{showDividerRef:Co(t,"showDivider"),mergedClsPrefixRef:e});const s=Hn(()=>{const{common:{cubicBezierEaseInOut:a},self:{fontSize:f,textColor:u,color:l,colorModal:d,colorPopover:p,borderColor:y,borderColorModal:h,borderColorPopover:g,borderRadius:w,colorHover:b,colorHoverModal:E,colorHoverPopover:A}}=i.value;return{"--n-font-size":f,"--n-bezier":a,"--n-text-color":u,"--n-color":l,"--n-border-radius":w,"--n-border-color":y,"--n-border-color-modal":h,"--n-border-color-popover":g,"--n-color-modal":d,"--n-color-popover":p,"--n-color-hover":b,"--n-color-hover-modal":E,"--n-color-hover-popover":A}}),c=n?Dn("list",void 0,s,t):void 0;return{mergedClsPrefix:e,rtlEnabled:o,cssVars:n?void 0:s,themeClass:c?.themeClass,onRender:c?.onRender}},render(){var t;const{$slots:e,mergedClsPrefix:n,onRender:r}=this;return r?.(),$("ul",{class:[`${n}-list`,this.rtlEnabled&&`${n}-list--rtl`,this.bordered&&`${n}-list--bordered`,this.showDivider&&`${n}-list--show-divider`,this.hoverable&&`${n}-list--hoverable`,this.clickable&&`${n}-list--clickable`,this.themeClass],style:this.cssVars},e.header?$("div",{class:`${n}-list__header`},e.header()):null,(t=e.default)===null||t===void 0?void 0:t.call(e),e.footer?$("div",{class:`${n}-list__footer`},e.footer()):null)}}),Sc=qe({name:"ListItem",setup(){const t=Do(Vr,null);return t||Wo("list-item","`n-list-item` must be placed in `n-list`."),{showDivider:t.showDividerRef,mergedClsPrefix:t.mergedClsPrefixRef}},render(){const{$slots:t,mergedClsPrefix:e}=this;return $("li",{class:`${e}-list-item`},t.prefix?$("div",{class:`${e}-list-item__prefix`},t.prefix()):null,t.default?$("div",{class:`${e}-list-item__main`},t):null,t.suffix?$("div",{class:`${e}-list-item__suffix`},t.suffix()):null,this.showDivider&&$("div",{class:`${e}-list-item__divider`}))}}),Mo=tt("thing",`
 display: flex;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
`,[tt("thing-avatar",`
 margin-right: 12px;
 margin-top: 2px;
 `),tt("thing-avatar-header-wrapper",`
 display: flex;
 flex-wrap: nowrap;
 `,[tt("thing-header-wrapper",`
 flex: 1;
 `)]),tt("thing-main",`
 flex-grow: 1;
 `,[tt("thing-header",`
 display: flex;
 margin-bottom: 4px;
 justify-content: space-between;
 align-items: center;
 `,[P("title",`
 font-size: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-title-text-color);
 `)]),P("description",[Vt("&:not(:last-child)",`
 margin-bottom: 4px;
 `)]),P("content",[Vt("&:not(:first-child)",`
 margin-top: 12px;
 `)]),P("footer",[Vt("&:not(:first-child)",`
 margin-top: 12px;
 `)]),P("action",[Vt("&:not(:first-child)",`
 margin-top: 12px;
 `)])])]),Oo=Object.assign(Object.assign({},ae.props),{title:String,titleExtra:String,description:String,descriptionStyle:[String,Object],content:String,contentStyle:[String,Object],contentIndented:Boolean}),vc=qe({name:"Thing",props:Oo,setup(t,{slots:e}){const{mergedClsPrefixRef:n,inlineThemeDisabled:r,mergedRtlRef:o}=_n(t),i=ae("Thing","-thing",Mo,Vo,t,n),s=Wr("Thing",o,n),c=Hn(()=>{const{self:{titleTextColor:f,textColor:u,titleFontWeight:l,fontSize:d},common:{cubicBezierEaseInOut:p}}=i.value;return{"--n-bezier":p,"--n-font-size":d,"--n-text-color":u,"--n-title-font-weight":l,"--n-title-text-color":f}}),a=r?Dn("thing",void 0,c,t):void 0;return()=>{var f;const{value:u}=n,l=s?s.value:!1;return(f=a?.onRender)===null||f===void 0||f.call(a),$("div",{class:[`${u}-thing`,a?.themeClass,l&&`${u}-thing--rtl`],style:r?void 0:c.value},e.avatar&&t.contentIndented?$("div",{class:`${u}-thing-avatar`},e.avatar()):null,$("div",{class:`${u}-thing-main`},!t.contentIndented&&(e.header||t.title||e["header-extra"]||t.titleExtra||e.avatar)?$("div",{class:`${u}-thing-avatar-header-wrapper`},e.avatar?$("div",{class:`${u}-thing-avatar`},e.avatar()):null,e.header||t.title||e["header-extra"]||t.titleExtra?$("div",{class:`${u}-thing-header-wrapper`},$("div",{class:`${u}-thing-header`},e.header||t.title?$("div",{class:`${u}-thing-header__title`},e.header?e.header():t.title):null,e["header-extra"]||t.titleExtra?$("div",{class:`${u}-thing-header__extra`},e["header-extra"]?e["header-extra"]():t.titleExtra):null),e.description||t.description?$("div",{class:`${u}-thing-main__description`,style:t.descriptionStyle},e.description?e.description():t.description):null):null):$(Dr,null,e.header||t.title||e["header-extra"]||t.titleExtra?$("div",{class:`${u}-thing-header`},e.header||t.title?$("div",{class:`${u}-thing-header__title`},e.header?e.header():t.title):null,e["header-extra"]||t.titleExtra?$("div",{class:`${u}-thing-header__extra`},e["header-extra"]?e["header-extra"]():t.titleExtra):null):null,e.description||t.description?$("div",{class:`${u}-thing-main__description`,style:t.descriptionStyle},e.description?e.description():t.description):null),e.default||t.content?$("div",{class:`${u}-thing-main__content`,style:t.contentStyle},e.default?e.default():t.content):null,e.footer?$("div",{class:`${u}-thing-main__footer`},e.footer()):null,e.action?$("div",{class:`${u}-thing-main__action`},e.action()):null))}}});function yn(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function Go(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function Kr(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Yo(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");yn(t.outputLen),yn(t.blockLen)}function jo(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Zo(t,e){Kr(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Zt={number:yn,bool:Go,bytes:Kr,hash:Yo,exists:jo,output:Zo},on=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sn=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Et=(t,e)=>t<<32-e|t>>>e,Qo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Qo)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Fo(t){if(typeof t!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function Wn(t){if(typeof t=="string"&&(t=Fo(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}function Xo(...t){if(!t.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(t.length===1)return t[0];const e=t.reduce((r,o)=>r+o.length,0),n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}let Pr=class{clone(){return this._cloneInto()}};function qr(t){const e=r=>t().update(Wn(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function zr(t=32){if(on&&typeof on.getRandomValues=="function")return on.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Jo(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,f=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+f,c,r)}let ti=class extends Pr{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=sn(this.buffer)}update(e){Zt.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=Wn(e);const i=e.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=sn(e);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(e.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Zt.exists(this),Zt.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let l=s;l<o;l++)n[l]=0;Jo(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=sn(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,u=this.get();if(f>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)c.setUint32(4*l,u[l],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=s,o%n&&e.buffer.set(r),e}};const ei=(t,e,n)=>t&e^~t&n,ni=(t,e,n)=>t&e^t&n^e&n,ri=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Rt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Nt=new Uint32Array(64);let Mr=class extends ti{constructor(){super(64,32,8,!1),this.A=Rt[0]|0,this.B=Rt[1]|0,this.C=Rt[2]|0,this.D=Rt[3]|0,this.E=Rt[4]|0,this.F=Rt[5]|0,this.G=Rt[6]|0,this.H=Rt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:s,G:c,H:a}=this;return[e,n,r,o,i,s,c,a]}set(e,n,r,o,i,s,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=a|0}process(e,n){for(let l=0;l<16;l++,n+=4)Nt[l]=e.getUint32(n,!1);for(let l=16;l<64;l++){const d=Nt[l-15],p=Nt[l-2],y=Et(d,7)^Et(d,18)^d>>>3,h=Et(p,17)^Et(p,19)^p>>>10;Nt[l]=h+Nt[l-7]+y+Nt[l-16]|0}let{A:r,B:o,C:i,D:s,E:c,F:a,G:f,H:u}=this;for(let l=0;l<64;l++){const d=Et(c,6)^Et(c,11)^Et(c,25),p=u+d+ei(c,a,f)+ri[l]+Nt[l]|0,h=(Et(r,2)^Et(r,13)^Et(r,22))+ni(r,o,i)|0;u=f,f=a,a=c,c=s+p|0,s=i,i=o,o=r,r=p+h|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,u=u+this.H|0,this.set(r,o,i,s,c,a,f,u)}roundClean(){Nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}},oi=class extends Mr{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}};const Be=qr(()=>new Mr);qr(()=>new oi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Or=BigInt(0),ze=BigInt(1),ii=BigInt(2),Me=t=>t instanceof Uint8Array,si=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ie(t){if(!Me(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=si[t[n]];return e}function Gr(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Vn(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function se(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(t.length%2)throw new Error("hex string is invalid: unpadded "+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=n*2,o=t.slice(r,r+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("invalid byte sequence");e[n]=i}return e}function et(t){return Vn(ie(t))}function Kn(t){if(!Me(t))throw new Error("Uint8Array expected");return Vn(ie(Uint8Array.from(t).reverse()))}const Pt=(t,e)=>se(t.toString(16).padStart(e*2,"0")),Yr=(t,e)=>Pt(t,e).reverse(),ci=t=>se(Gr(t));function j(t,e,n){let r;if(typeof e=="string")try{r=se(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(Me(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function at(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Me(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function ai(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Oe(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new TextEncoder().encode(t)}function fi(t){let e;for(e=0;t>Or;t>>=ze,e+=1);return e}const li=(t,e)=>t>>BigInt(e)&ze,ui=(t,e,n)=>t|(n?ze:Or)<<BigInt(e),Pn=t=>(ii<<BigInt(t-1))-ze,cn=t=>new Uint8Array(t),sr=t=>Uint8Array.from(t);function jr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=cn(t),o=cn(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...l)=>n(o,r,...l),a=(l=cn())=>{o=c(sr([0]),l),r=c(),l.length!==0&&(o=c(sr([1]),l),r=c())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const d=[];for(;l<e;){r=c();const p=r.slice();d.push(p),l+=r.length}return at(...d)};return(l,d)=>{s(),a(l);let p;for(;!(p=d(f()));)a();return s(),p}}const hi={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function fe(t,e,n={}){const r=(o,i,s)=>{const c=hi[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const a=t[o];if(!(s&&a===void 0)&&!c(a,t))throw new Error(`Invalid param ${String(o)}=${a} (${typeof a}), expected ${i}`)};for(const[o,i]of Object.entries(e))r(o,i,!1);for(const[o,i]of Object.entries(n))r(o,i,!0);return t}const di=Object.freeze(Object.defineProperty({__proto__:null,bitGet:li,bitLen:fi,bitMask:Pn,bitSet:ui,bytesToHex:ie,bytesToNumberBE:et,bytesToNumberLE:Kn,concatBytes:at,createHmacDrbg:jr,ensureBytes:j,equalBytes:ai,hexToBytes:se,hexToNumber:Vn,numberToBytesBE:Pt,numberToBytesLE:Yr,numberToHexUnpadded:Gr,numberToVarBytesBE:ci,utf8ToBytes:Oe,validateObject:fe},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const G=BigInt(0),K=BigInt(1),jt=BigInt(2),pi=BigInt(3),bn=BigInt(4),cr=BigInt(5),ar=BigInt(8);BigInt(9);BigInt(16);function O(t,e){const n=t%e;return n>=G?n:e+n}function gi(t,e,n){if(n<=G||e<G)throw new Error("Expected power/modulo > 0");if(n===K)return G;let r=K;for(;e>G;)e&K&&(r=r*t%n),t=t*t%n,e>>=K;return r}function ht(t,e,n){let r=t;for(;e-- >G;)r*=r,r%=n;return r}function mn(t,e){if(t===G||e<=G)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=O(t,e),r=e,o=G,i=K;for(;n!==G;){const c=r/n,a=r%n,f=o-i*c;r=n,n=a,o=i,i=f}if(r!==K)throw new Error("invert: does not exist");return O(o,e)}function wi(t){const e=(t-K)/jt;let n,r,o;for(n=t-K,r=0;n%jt===G;n/=jt,r++);for(o=jt;o<t&&gi(o,e,t)!==t-K;o++);if(r===1){const s=(t+K)/bn;return function(a,f){const u=a.pow(f,s);if(!a.eql(a.sqr(u),f))throw new Error("Cannot find square root");return u}}const i=(n+K)/jt;return function(c,a){if(c.pow(a,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=r,u=c.pow(c.mul(c.ONE,o),n),l=c.pow(a,i),d=c.pow(a,n);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let p=1;for(let h=c.sqr(d);p<f&&!c.eql(h,c.ONE);p++)h=c.sqr(h);const y=c.pow(u,K<<BigInt(f-p-1));u=c.sqr(y),l=c.mul(l,y),d=c.mul(d,u),f=p}return l}}function yi(t){if(t%bn===pi){const e=(t+K)/bn;return function(r,o){const i=r.pow(o,e);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%ar===cr){const e=(t-cr)/ar;return function(r,o){const i=r.mul(o,jt),s=r.pow(i,e),c=r.mul(o,s),a=r.mul(r.mul(c,jt),s),f=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return wi(t)}const bi=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Zr(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=bi.reduce((r,o)=>(r[o]="function",r),e);return fe(t,n)}function mi(t,e,n){if(n<G)throw new Error("Expected power > 0");if(n===G)return t.ONE;if(n===K)return e;let r=t.ONE,o=e;for(;n>G;)n&K&&(r=t.mul(r,o)),o=t.sqr(o),n>>=K;return r}function Ei(t,e){const n=new Array(e.length),r=e.reduce((i,s,c)=>t.is0(s)?i:(n[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return e.reduceRight((i,s,c)=>t.is0(s)?i:(n[c]=t.mul(i,n[c]),t.mul(i,s)),o),n}function qn(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function xi(t,e,n=!1,r={}){if(t<=G)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=qn(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=yi(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:Pn(o),ZERO:G,ONE:K,create:a=>O(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return G<=a&&a<t},is0:a=>a===G,isOdd:a=>(a&K)===K,neg:a=>O(-a,t),eql:(a,f)=>a===f,sqr:a=>O(a*a,t),add:(a,f)=>O(a+f,t),sub:(a,f)=>O(a-f,t),mul:(a,f)=>O(a*f,t),pow:(a,f)=>mi(c,a,f),div:(a,f)=>O(a*mn(f,t),t),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>mn(a,t),sqrt:r.sqrt||(a=>s(c,a)),invertBatch:a=>Ei(c,a),cmov:(a,f,u)=>u?f:a,toBytes:a=>n?Yr(a,i):Pt(a,i),fromBytes:a=>{if(a.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${a.length}`);return n?Kn(a):et(a)}});return Object.freeze(c)}function Si(t,e,n=!1){t=j("privateHash",t);const r=t.length,o=qn(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);const i=n?Kn(t):et(t);return O(i,e-K)+K}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vi=BigInt(0),an=BigInt(1);function Ai(t,e){const n=(o,i)=>{const s=i.negate();return o?s:i},r=o=>{const i=Math.ceil(e/o)+1,s=2**(o-1);return{windows:i,windowSize:s}};return{constTimeNegate:n,unsafeLadder(o,i){let s=t.ZERO,c=o;for(;i>vi;)i&an&&(s=s.add(c)),c=c.double(),i>>=an;return s},precomputeWindow(o,i){const{windows:s,windowSize:c}=r(i),a=[];let f=o,u=f;for(let l=0;l<s;l++){u=f,a.push(u);for(let d=1;d<c;d++)u=u.add(f),a.push(u);f=u.double()}return a},wNAF(o,i,s){const{windows:c,windowSize:a}=r(o);let f=t.ZERO,u=t.BASE;const l=BigInt(2**o-1),d=2**o,p=BigInt(o);for(let y=0;y<c;y++){const h=y*a;let g=Number(s&l);s>>=p,g>a&&(g-=d,s+=an);const w=h,b=h+Math.abs(g)-1,E=y%2!==0,A=g<0;g===0?u=u.add(n(E,i[w])):f=f.add(n(A,i[b]))}return{p:f,f:u}},wNAFCached(o,i,s,c){const a=o._WINDOW_SIZE||1;let f=i.get(o);return f||(f=this.precomputeWindow(o,a),a!==1&&i.set(o,c(f))),this.wNAF(a,f,s)}}}function Qr(t){return Zr(t.Fp),fe(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...qn(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ki(t){const e=Qr(t);fe(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ii,hexToBytes:Ti}=di,Qt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=Qt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ii(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=Qt,n=typeof t=="string"?Ti(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=Qt._parseInt(n.subarray(2)),{d:s,l:c}=Qt._parseInt(i);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,n=f=>{const u=f.toString(16);return u.length&1?`0${u}`:u},r=e(n(t.s)),o=e(n(t.r)),i=r.length/2,s=o.length/2,c=n(i),a=n(s);return`30${n(s+i+4)}02${a}${o}02${c}${r}`}},gt=BigInt(0),q=BigInt(1),kt=BigInt(2),$e=BigInt(3),fr=BigInt(4);function Bi(t){const e=ki(t),{Fp:n}=e,r=e.toBytes||((y,h,g)=>{const w=h.toAffine();return at(Uint8Array.from([4]),n.toBytes(w.x),n.toBytes(w.y))}),o=e.fromBytes||(y=>{const h=y.subarray(1),g=n.fromBytes(h.subarray(0,n.BYTES)),w=n.fromBytes(h.subarray(n.BYTES,2*n.BYTES));return{x:g,y:w}});function i(y){const{a:h,b:g}=e,w=n.sqr(y),b=n.mul(w,y);return n.add(n.add(b,n.mul(y,h)),g)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function s(y){return typeof y=="bigint"&&gt<y&&y<e.n}function c(y){if(!s(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(y){const{allowedPrivateKeyLengths:h,nByteLength:g,wrapPrivateKey:w,n:b}=e;if(h&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=ie(y)),typeof y!="string"||!h.includes(y.length))throw new Error("Invalid key");y=y.padStart(g*2,"0")}let E;try{E=typeof y=="bigint"?y:et(j("private key",y,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`)}return w&&(E=O(E,b)),c(E),E}const f=new Map;function u(y){if(!(y instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(h,g,w){if(this.px=h,this.py=g,this.pz=w,h==null||!n.isValid(h))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(w==null||!n.isValid(w))throw new Error("z required")}static fromAffine(h){const{x:g,y:w}=h||{};if(!h||!n.isValid(g)||!n.isValid(w))throw new Error("invalid affine point");if(h instanceof l)throw new Error("projective point not allowed");const b=E=>n.eql(E,n.ZERO);return b(g)&&b(w)?l.ZERO:new l(g,w,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const g=n.invertBatch(h.map(w=>w.pz));return h.map((w,b)=>w.toAffine(g[b])).map(l.fromAffine)}static fromHex(h){const g=l.fromAffine(o(j("pointHex",h)));return g.assertValidity(),g}static fromPrivateKey(h){return l.BASE.multiply(a(h))}_setWindowSize(h){this._WINDOW_SIZE=h,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:h,y:g}=this.toAffine();if(!n.isValid(h)||!n.isValid(g))throw new Error("bad point: x or y not FE");const w=n.sqr(g),b=i(h);if(!n.eql(w,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(n.isOdd)return!n.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){u(h);const{px:g,py:w,pz:b}=this,{px:E,py:A,pz:v}=h,x=n.eql(n.mul(g,v),n.mul(E,b)),k=n.eql(n.mul(w,v),n.mul(A,b));return x&&k}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:h,b:g}=e,w=n.mul(g,$e),{px:b,py:E,pz:A}=this;let v=n.ZERO,x=n.ZERO,k=n.ZERO,I=n.mul(b,b),ot=n.mul(E,E),R=n.mul(A,A),B=n.mul(b,E);return B=n.add(B,B),k=n.mul(b,A),k=n.add(k,k),v=n.mul(h,k),x=n.mul(w,R),x=n.add(v,x),v=n.sub(ot,x),x=n.add(ot,x),x=n.mul(v,x),v=n.mul(B,v),k=n.mul(w,k),R=n.mul(h,R),B=n.sub(I,R),B=n.mul(h,B),B=n.add(B,k),k=n.add(I,I),I=n.add(k,I),I=n.add(I,R),I=n.mul(I,B),x=n.add(x,I),R=n.mul(E,A),R=n.add(R,R),I=n.mul(R,B),v=n.sub(v,I),k=n.mul(R,ot),k=n.add(k,k),k=n.add(k,k),new l(v,x,k)}add(h){u(h);const{px:g,py:w,pz:b}=this,{px:E,py:A,pz:v}=h;let x=n.ZERO,k=n.ZERO,I=n.ZERO;const ot=e.a,R=n.mul(e.b,$e);let B=n.mul(g,E),Q=n.mul(w,A),it=n.mul(b,v),Bt=n.add(g,w),m=n.add(E,A);Bt=n.mul(Bt,m),m=n.add(B,Q),Bt=n.sub(Bt,m),m=n.add(g,b);let S=n.add(E,v);return m=n.mul(m,S),S=n.add(B,it),m=n.sub(m,S),S=n.add(w,b),x=n.add(A,v),S=n.mul(S,x),x=n.add(Q,it),S=n.sub(S,x),I=n.mul(ot,m),x=n.mul(R,it),I=n.add(x,I),x=n.sub(Q,I),I=n.add(Q,I),k=n.mul(x,I),Q=n.add(B,B),Q=n.add(Q,B),it=n.mul(ot,it),m=n.mul(R,m),Q=n.add(Q,it),it=n.sub(B,it),it=n.mul(ot,it),m=n.add(m,it),B=n.mul(Q,m),k=n.add(k,B),B=n.mul(S,m),x=n.mul(Bt,x),x=n.sub(x,B),B=n.mul(Bt,Q),I=n.mul(S,I),I=n.add(I,B),new l(x,k,I)}subtract(h){return this.add(h.negate())}is0(){return this.equals(l.ZERO)}wNAF(h){return p.wNAFCached(this,f,h,g=>{const w=n.invertBatch(g.map(b=>b.pz));return g.map((b,E)=>b.toAffine(w[E])).map(l.fromAffine)})}multiplyUnsafe(h){const g=l.ZERO;if(h===gt)return g;if(c(h),h===q)return this;const{endo:w}=e;if(!w)return p.unsafeLadder(this,h);let{k1neg:b,k1:E,k2neg:A,k2:v}=w.splitScalar(h),x=g,k=g,I=this;for(;E>gt||v>gt;)E&q&&(x=x.add(I)),v&q&&(k=k.add(I)),I=I.double(),E>>=q,v>>=q;return b&&(x=x.negate()),A&&(k=k.negate()),k=new l(n.mul(k.px,w.beta),k.py,k.pz),x.add(k)}multiply(h){c(h);let g=h,w,b;const{endo:E}=e;if(E){const{k1neg:A,k1:v,k2neg:x,k2:k}=E.splitScalar(g);let{p:I,f:ot}=this.wNAF(v),{p:R,f:B}=this.wNAF(k);I=p.constTimeNegate(A,I),R=p.constTimeNegate(x,R),R=new l(n.mul(R.px,E.beta),R.py,R.pz),w=I.add(R),b=ot.add(B)}else{const{p:A,f:v}=this.wNAF(g);w=A,b=v}return l.normalizeZ([w,b])[0]}multiplyAndAddUnsafe(h,g,w){const b=l.BASE,E=(v,x)=>x===gt||x===q||!v.equals(b)?v.multiplyUnsafe(x):v.multiply(x),A=E(this,g).add(E(h,w));return A.is0()?void 0:A}toAffine(h){const{px:g,py:w,pz:b}=this,E=this.is0();h==null&&(h=E?n.ONE:n.inv(b));const A=n.mul(g,h),v=n.mul(w,h),x=n.mul(b,h);if(E)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:A,y:v}}isTorsionFree(){const{h,isTorsionFree:g}=e;if(h===q)return!0;if(g)return g(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:g}=e;return h===q?this:g?g(l,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return this.assertValidity(),r(l,this,h)}toHex(h=!0){return ie(this.toRawBytes(h))}}l.BASE=new l(e.Gx,e.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const d=e.nBitLength,p=Ai(l,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:s}}function $i(t){const e=Qr(t);return fe(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ui(t){const e=$i(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(m){return gt<m&&m<n.ORDER}function c(m){return O(m,r)}function a(m){return mn(m,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:d}=Bi({...e,toBytes(m,S,T){const N=S.toAffine(),U=n.toBytes(N.x),J=at;return T?J(Uint8Array.from([S.hasEvenY()?2:3]),U):J(Uint8Array.from([4]),U,n.toBytes(N.y))},fromBytes(m){const S=m.length,T=m[0],N=m.subarray(1);if(S===o&&(T===2||T===3)){const U=et(N);if(!s(U))throw new Error("Point is not on curve");const J=l(U);let ut=n.sqrt(J);const st=(ut&q)===q;return(T&1)===1!==st&&(ut=n.neg(ut)),{x:U,y:ut}}else if(S===i&&T===4){const U=n.fromBytes(N.subarray(0,n.BYTES)),J=n.fromBytes(N.subarray(n.BYTES,2*n.BYTES));return{x:U,y:J}}else throw new Error(`Point of length ${S} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),p=m=>ie(Pt(m,e.nByteLength));function y(m){const S=r>>q;return m>S}function h(m){return y(m)?c(-m):m}const g=(m,S,T)=>et(m.slice(S,T));class w{constructor(S,T,N){this.r=S,this.s=T,this.recovery=N,this.assertValidity()}static fromCompact(S){const T=e.nByteLength;return S=j("compactSignature",S,T*2),new w(g(S,0,T),g(S,T,2*T))}static fromDER(S){const{r:T,s:N}=Qt.toSig(j("DER",S));return new w(T,N)}assertValidity(){if(!d(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!d(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(S){return new w(this.r,this.s,S)}recoverPublicKey(S){const{r:T,s:N,recovery:U}=this,J=k(j("msgHash",S));if(U==null||![0,1,2,3].includes(U))throw new Error("recovery id invalid");const ut=U===2||U===3?T+e.n:T;if(ut>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const st=U&1?"03":"02",$t=f.fromHex(st+p(ut)),Ut=a(ut),Jt=c(-J*Ut),he=c(N*Ut),Lt=f.BASE.multiplyAndAddUnsafe($t,Jt,he);if(!Lt)throw new Error("point at infinify");return Lt.assertValidity(),Lt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return se(this.toDERHex())}toDERHex(){return Qt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return se(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const b={isValidPrivateKey(m){try{return u(m),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const m=e.randomBytes(n.BYTES+8),S=Si(m,r);return Pt(S,e.nByteLength)},precompute(m=8,S=f.BASE){return S._setWindowSize(m),S.multiply(BigInt(3)),S}};function E(m,S=!0){return f.fromPrivateKey(m).toRawBytes(S)}function A(m){const S=m instanceof Uint8Array,T=typeof m=="string",N=(S||T)&&m.length;return S?N===o||N===i:T?N===2*o||N===2*i:m instanceof f}function v(m,S,T=!0){if(A(m))throw new Error("first arg must be private key");if(!A(S))throw new Error("second arg must be public key");return f.fromHex(S).multiply(u(m)).toRawBytes(T)}const x=e.bits2int||function(m){const S=et(m),T=m.length*8-e.nBitLength;return T>0?S>>BigInt(T):S},k=e.bits2int_modN||function(m){return c(x(m))},I=Pn(e.nBitLength);function ot(m){if(typeof m!="bigint")throw new Error("bigint expected");if(!(gt<=m&&m<I))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Pt(m,e.nByteLength)}function R(m,S,T=B){if(["recovered","canonical"].some(Gt=>Gt in T))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:U}=e;let{lowS:J,prehash:ut,extraEntropy:st}=T;J==null&&(J=!0),m=j("msgHash",m),ut&&(m=j("prehashed msgHash",N(m)));const $t=k(m),Ut=u(S),Jt=[ot(Ut),ot($t)];if(st!=null){const Gt=st===!0?U(n.BYTES):st;Jt.push(j("extraEntropy",Gt,n.BYTES))}const he=at(...Jt),Lt=$t;function nn(Gt){const te=x(Gt);if(!d(te))return;const rr=a(te),mt=f.BASE.multiply(te).toAffine(),ee=c(mt.x);if(ee===gt)return;const xe=c(rr*c(Lt+ee*Ut));if(xe===gt)return;let or=(mt.x===ee?0:2)|Number(mt.y&q),ir=xe;return J&&y(xe)&&(ir=h(xe),or^=1),new w(ee,ir,or)}return{seed:he,k2sig:nn}}const B={lowS:e.lowS,prehash:!1},Q={lowS:e.lowS,prehash:!1};function it(m,S,T=B){const{seed:N,k2sig:U}=R(m,S,T);return jr(e.hash.outputLen,e.nByteLength,e.hmac)(N,U)}f.BASE._setWindowSize(8);function Bt(m,S,T,N=Q){const U=m;if(S=j("msgHash",S),T=j("publicKey",T),"strict"in N)throw new Error("options.strict was renamed to lowS");const{lowS:J,prehash:ut}=N;let st,$t;try{if(typeof U=="string"||U instanceof Uint8Array)try{st=w.fromDER(U)}catch(mt){if(!(mt instanceof Qt.Err))throw mt;st=w.fromCompact(U)}else if(typeof U=="object"&&typeof U.r=="bigint"&&typeof U.s=="bigint"){const{r:mt,s:ee}=U;st=new w(mt,ee)}else throw new Error("PARSE");$t=f.fromHex(T)}catch(mt){if(mt.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(J&&st.hasHighS())return!1;ut&&(S=e.hash(S));const{r:Ut,s:Jt}=st,he=k(S),Lt=a(Jt),nn=c(he*Lt),Gt=c(Ut*Lt),te=f.BASE.multiplyAndAddUnsafe($t,nn,Gt)?.toAffine();return te?c(te.x)===Ut:!1}return{CURVE:e,getPublicKey:E,getSharedSecret:v,sign:it,verify:Bt,ProjectivePoint:f,Signature:w,utils:b}}function Li(t,e){const n=t.ORDER;let r=gt;for(let d=n-q;d%kt===gt;d/=kt)r+=q;const o=r,i=(n-q)/kt**o,s=(i-q)/kt,c=kt**o-q,a=kt**(o-q),f=t.pow(e,i),u=t.pow(e,(i+q)/kt);let l=(d,p)=>{let y=f,h=t.pow(p,c),g=t.sqr(h);g=t.mul(g,p);let w=t.mul(d,g);w=t.pow(w,s),w=t.mul(w,h),h=t.mul(w,p),g=t.mul(w,d);let b=t.mul(g,h);w=t.pow(b,a);let E=t.eql(w,t.ONE);h=t.mul(g,u),w=t.mul(b,y),g=t.cmov(h,g,E),b=t.cmov(w,b,E);for(let A=o;A>q;A--){let v=kt**(A-kt),x=t.pow(b,v);const k=t.eql(x,t.ONE);h=t.mul(g,y),y=t.mul(y,y),x=t.mul(b,y),g=t.cmov(h,g,k),b=t.cmov(x,b,k)}return{isValid:E,value:g}};if(t.ORDER%fr===$e){const d=(t.ORDER-$e)/fr,p=t.sqrt(t.neg(e));l=(y,h)=>{let g=t.sqr(h);const w=t.mul(y,h);g=t.mul(g,w);let b=t.pow(g,d);b=t.mul(b,w);const E=t.mul(b,p),A=t.mul(t.sqr(b),h),v=t.eql(A,y);let x=t.cmov(E,b,v);return{isValid:v,value:x}}}return l}function Ri(t,e){if(Zr(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=Li(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,s,c,a,f,u,l;o=t.sqr(r),o=t.mul(o,e.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,e.B),c=t.cmov(e.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,e.A),i=t.sqr(s),f=t.sqr(c),a=t.mul(f,e.A),i=t.add(i,a),i=t.mul(i,s),f=t.mul(f,c),a=t.mul(f,e.B),i=t.add(i,a),u=t.mul(o,s);const{isValid:d,value:p}=n(i,f);l=t.mul(o,r),l=t.mul(l,p),u=t.cmov(u,s,d),l=t.cmov(l,p,d);const y=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,y),u=t.div(u,c),{x:u,y:l}}}function Ni(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return Oe(t);throw new Error("DST must be Uint8Array or string")}const Ci=et;function Dt(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function _i(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function be(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function zn(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Hi(t,e,n,r){be(t),be(e),zn(n),e.length>255&&(e=r(at(Oe("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(n/o);if(s>255)throw new Error("Invalid xmd length");const c=at(e,Dt(e.length,1)),a=Dt(0,i),f=Dt(n,2),u=new Array(s),l=r(at(a,t,f,Dt(0,1),c));u[0]=r(at(l,Dt(1,1),c));for(let p=1;p<=s;p++){const y=[_i(l,u[p-1]),Dt(p+1,1),c];u[p]=r(at(...y))}return at(...u).slice(0,n)}function Di(t,e,n,r,o){if(be(t),be(e),zn(n),e.length>255){const i=Math.ceil(2*r/8);e=o.create({dkLen:i}).update(Oe("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(Dt(n,2)).update(e).update(Dt(e.length,1)).digest()}function lr(t,e,n){fe(n,{DST:"string",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:c,DST:a}=n;be(t),zn(e);const f=Ni(a),u=r.toString(2).length,l=Math.ceil((u+o)/8),d=e*i*l;let p;if(c==="xmd")p=Hi(t,f,d,s);else if(c==="xof")p=Di(t,f,d,o,s);else if(c==="_internal_pass")p=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(e);for(let h=0;h<e;h++){const g=new Array(i);for(let w=0;w<i;w++){const b=l*(w+h*i),E=p.subarray(b,b+l);g[w]=O(Ci(E),r)}y[h]=g}return y}function Wi(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[i,s,c,a]=n.map(f=>f.reduce((u,l)=>t.add(t.mul(u,r),l)));return r=t.div(i,s),o=t.mul(o,t.div(c,a)),{x:r,y:o}}}function Vi(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=lr(r,2,{...n,DST:n.DST,...o}),s=t.fromAffine(e(i[0])),c=t.fromAffine(e(i[1])),a=s.add(c).clearCofactor();return a.assertValidity(),a},encodeToCurve(r,o){const i=lr(r,1,{...n,DST:n.encodeDST,...o}),s=t.fromAffine(e(i[0])).clearCofactor();return s.assertValidity(),s}}}class Fr extends Pr{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Zt.hash(e);const r=Wn(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?e.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=e.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(e){return Zt.exists(this),this.iHash.update(e),this}digestInto(e){Zt.exists(this),Zt.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return e=e,e.finished=o,e.destroyed=i,e.blockLen=s,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Xr=(t,e,n)=>new Fr(t,e).update(n).digest();Xr.create=(t,e)=>new Fr(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ki(t){return{hash:t,hmac:(e,...n)=>Xr(t,e,Xo(...n)),randomBytes:zr}}function Pi(t,e){const n=r=>Ui({...t,...Ki(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ge=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ue=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Jr=BigInt(1),Le=BigInt(2),ur=(t,e)=>(t+e/Le)/e;function to(t){const e=Ge,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),c=BigInt(44),a=BigInt(88),f=t*t*t%e,u=f*f*t%e,l=ht(u,n,e)*u%e,d=ht(l,n,e)*u%e,p=ht(d,Le,e)*f%e,y=ht(p,o,e)*p%e,h=ht(y,i,e)*y%e,g=ht(h,c,e)*h%e,w=ht(g,a,e)*g%e,b=ht(w,c,e)*h%e,E=ht(b,n,e)*u%e,A=ht(E,s,e)*y%e,v=ht(A,r,e)*f%e,x=ht(v,Le,e);if(!zt.eql(zt.sqr(x),t))throw new Error("Cannot find square root");return x}const zt=xi(Ge,void 0,void 0,{sqrt:to}),le=Pi({a:BigInt(0),b:BigInt(7),Fp:zt,n:Ue,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ue,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Jr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,s=BigInt("0x100000000000000000000000000000000"),c=ur(i*t,e),a=ur(-r*t,e);let f=O(t-c*n-a*o,e),u=O(-c*r-a*i,e);const l=f>s,d=u>s;if(l&&(f=e-f),d&&(u=e-u),f>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:f,k2neg:d,k2:u}}}},Be),Ye=BigInt(0),eo=t=>typeof t=="bigint"&&Ye<t&&t<Ge,qi=t=>typeof t=="bigint"&&Ye<t&&t<Ue,hr={};function Re(t,...e){let n=hr[t];if(n===void 0){const r=Be(Uint8Array.from(t,o=>o.charCodeAt(0)));n=at(r,r),hr[t]=n}return Be(at(n,...e))}const Mn=t=>t.toRawBytes(!0).slice(1),En=t=>Pt(t,32),fn=t=>O(t,Ge),me=t=>O(t,Ue),On=le.ProjectivePoint,zi=(t,e,n)=>On.BASE.multiplyAndAddUnsafe(t,e,n);function xn(t){let e=le.utils.normPrivateKeyToScalar(t),n=On.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:me(-e),bytes:Mn(n)}}function no(t){if(!eo(t))throw new Error("bad x: need 0 < x < p");const e=fn(t*t),n=fn(e*t+BigInt(7));let r=to(n);r%Le!==Ye&&(r=fn(-r));const o=new On(t,r,Jr);return o.assertValidity(),o}function ro(...t){return me(et(Re("BIP0340/challenge",...t)))}function Mi(t){return xn(t).bytes}function Oi(t,e,n=zr(32)){const r=j("message",t),{bytes:o,scalar:i}=xn(e),s=j("auxRand",n,32),c=En(i^et(Re("BIP0340/aux",s))),a=Re("BIP0340/nonce",c,o,r),f=me(et(a));if(f===Ye)throw new Error("sign failed: k is zero");const{bytes:u,scalar:l}=xn(f),d=ro(u,o,r),p=new Uint8Array(64);if(p.set(u,0),p.set(En(me(l+d*i)),32),!oo(p,r,o))throw new Error("sign: Invalid signature produced");return p}function oo(t,e,n){const r=j("signature",t,64),o=j("message",e),i=j("publicKey",n,32);try{const s=no(et(i)),c=et(r.subarray(0,32));if(!eo(c))return!1;const a=et(r.subarray(32,64));if(!qi(a))return!1;const f=ro(En(c),Mn(s),o),u=zi(s,a,me(-f));return!(!u||!u.hasEvenY()||u.toAffine().x!==c)}catch{return!1}}const ft={getPublicKey:Mi,sign:Oi,verify:oo,utils:{randomPrivateKey:le.utils.randomPrivateKey,lift_x:no,pointToBytes:Mn,numberToBytesBE:Pt,bytesToNumberBE:et,taggedHash:Re,mod:O}},Gi=Wi(zt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))),Yi=Ri(zt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:zt.create(BigInt("-11"))});Vi(le.ProjectivePoint,t=>{const{x:e,y:n}=Yi(zt.create(t[0]));return Gi(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:zt.ORDER,m:1,k:128,expand:"xmd",hash:Be});function Sn(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function ji(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function io(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Zi(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Sn(t.outputLen),Sn(t.blockLen)}function Qi(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Fi(t,e){io(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ln={number:Sn,bool:ji,bytes:io,hash:Zi,exists:Qi,output:Fi},un=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const so=t=>t instanceof Uint8Array,$c=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),hn=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),xt=(t,e)=>t<<32-e|t>>>e,Xi=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Xi)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Ji(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Gn(t){if(typeof t=="string"&&(t=Ji(t)),!so(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Uc(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!so(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class ts{clone(){return this._cloneInto()}}function Yn(t){const e=r=>t().update(Gn(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Lc(t){const e=(r,o)=>t(o).update(Gn(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function Rc(t=32){if(un&&typeof un.getRandomValues=="function")return un.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function es(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),c=Number(n&i),a=r?4:0,f=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+f,c,r)}class co extends ts{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=hn(this.buffer)}update(e){ln.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=Gn(e);const i=e.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=hn(e);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(e.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ln.exists(this),ln.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let l=s;l<o;l++)n[l]=0;es(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=hn(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,u=this.get();if(f>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)c.setUint32(4*l,u[l],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return e.length=o,e.pos=c,e.finished=i,e.destroyed=s,o%n&&e.buffer.set(r),e}}const ns=(t,e,n)=>t&e^~t&n,rs=(t,e,n)=>t&e^t&n^e&n,os=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Ct=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_t=new Uint32Array(64);class ao extends co{constructor(){super(64,32,8,!1),this.A=Ct[0]|0,this.B=Ct[1]|0,this.C=Ct[2]|0,this.D=Ct[3]|0,this.E=Ct[4]|0,this.F=Ct[5]|0,this.G=Ct[6]|0,this.H=Ct[7]|0}get(){const{A:e,B:n,C:r,D:o,E:i,F:s,G:c,H:a}=this;return[e,n,r,o,i,s,c,a]}set(e,n,r,o,i,s,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=s|0,this.G=c|0,this.H=a|0}process(e,n){for(let l=0;l<16;l++,n+=4)_t[l]=e.getUint32(n,!1);for(let l=16;l<64;l++){const d=_t[l-15],p=_t[l-2],y=xt(d,7)^xt(d,18)^d>>>3,h=xt(p,17)^xt(p,19)^p>>>10;_t[l]=h+_t[l-7]+y+_t[l-16]|0}let{A:r,B:o,C:i,D:s,E:c,F:a,G:f,H:u}=this;for(let l=0;l<64;l++){const d=xt(c,6)^xt(c,11)^xt(c,25),p=u+d+ns(c,a,f)+os[l]+_t[l]|0,h=(xt(r,2)^xt(r,13)^xt(r,22))+rs(r,o,i)|0;u=f,f=a,a=c,c=s+p|0,s=i,i=o,o=r,r=p+h|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,u=u+this.H|0,this.set(r,o,i,s,c,a,f,u)}roundClean(){_t.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class is extends ao{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const wt=Yn(()=>new ao);Yn(()=>new is);const ss=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),fo=Uint8Array.from({length:16},(t,e)=>e),cs=fo.map(t=>(9*t+5)%16);let jn=[fo],Zn=[cs];for(let t=0;t<4;t++)for(let e of[jn,Zn])e.push(e[t].map(n=>ss[n]));const lo=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),as=jn.map((t,e)=>t.map(n=>lo[e][n])),fs=Zn.map((t,e)=>t.map(n=>lo[e][n])),ls=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),us=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),Se=(t,e)=>t<<e|t>>>32-e;function dr(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}const ve=new Uint32Array(16);class hs extends co{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:n,h2:r,h3:o,h4:i}=this;return[e,n,r,o,i]}set(e,n,r,o,i){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=o|0,this.h4=i|0}process(e,n){for(let p=0;p<16;p++,n+=4)ve[p]=e.getUint32(n,!0);let r=this.h0|0,o=r,i=this.h1|0,s=i,c=this.h2|0,a=c,f=this.h3|0,u=f,l=this.h4|0,d=l;for(let p=0;p<5;p++){const y=4-p,h=ls[p],g=us[p],w=jn[p],b=Zn[p],E=as[p],A=fs[p];for(let v=0;v<16;v++){const x=Se(r+dr(p,i,c,f)+ve[w[v]]+h,E[v])+l|0;r=l,l=f,f=Se(c,10)|0,c=i,i=x}for(let v=0;v<16;v++){const x=Se(o+dr(y,s,a,u)+ve[b[v]]+g,A[v])+d|0;o=d,d=u,u=Se(a,10)|0,a=s,s=x}}this.set(this.h1+c+u|0,this.h2+f+d|0,this.h3+l+o|0,this.h4+r+s|0,this.h0+i+a|0)}roundClean(){ve.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const ds=Yn(()=>new hs);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ft(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function vt(...t){const e=(o,i)=>s=>o(i(s)),n=Array.from(t).reverse().reduce((o,i)=>o?e(o,i.encode):i.encode,void 0),r=t.reduce((o,i)=>o?e(o,i.decode):i.decode,void 0);return{encode:n,decode:r}}function It(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return e.map(n=>{if(Ft(n),n<0||n>=t.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${t.length})`);return t[n]})},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("alphabet.decode input should be array of strings");return e.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=t.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${t}`);return r})}}}function Tt(t=""){if(typeof t!="string")throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of e)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return e.join(t)},decode:e=>{if(typeof e!="string")throw new Error("join.decode input should be string");return e.split(t)}}}function je(t,e="="){if(Ft(t),typeof e!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*t%8;)n.push(e);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of n)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let r=n.length;if(r*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--)if(!((r-1)*t%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function uo(t){if(typeof t!="function")throw new Error("normalize fn should be function");return{encode:e=>e,decode:e=>t(e)}}function pr(t,e,n){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let r=0;const o=[],i=Array.from(t);for(i.forEach(s=>{if(Ft(s),s<0||s>=e)throw new Error(`Wrong integer: ${s}`)});;){let s=0,c=!0;for(let a=r;a<i.length;a++){const f=i[a],u=e*s+f;if(!Number.isSafeInteger(u)||e*s/e!==s||u-f!==e*s)throw new Error("convertRadix: carry overflow");if(s=u%n,i[a]=Math.floor(u/n),!Number.isSafeInteger(i[a])||i[a]*n+s!==u)throw new Error("convertRadix: carry overflow");if(c)i[a]?c=!1:r=a;else continue}if(o.push(s),c)break}for(let s=0;s<t.length-1&&t[s]===0;s++)o.push(0);return o.reverse()}const ho=(t,e)=>e?ho(e,t%e):t,Ne=(t,e)=>t+(e-ho(t,e));function vn(t,e,n,r){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(Ne(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${Ne(e,n)}`);let o=0,i=0;const s=2**n-1,c=[];for(const a of t){if(Ft(a),a>=2**e)throw new Error(`convertRadix2: invalid data word=${a} from=${e}`);if(o=o<<e|a,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=n;i-=n)c.push((o>>i-n&s)>>>0);o&=2**i-1}if(o=o<<n-i&s,!r&&i>=e)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&i>0&&c.push(o>>>0),c}function ps(t){return Ft(t),{encode:e=>{if(!(e instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return pr(Array.from(e),2**8,t)},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(pr(e,t,2**8))}}}function Mt(t,e=!1){if(Ft(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Ne(8,t)>32||Ne(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return vn(Array.from(n),8,t,!e)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(vn(n,t,8,e))}}}function gr(t){if(typeof t!="function")throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch{}}}function gs(t,e){if(Ft(t),typeof e!="function")throw new Error("checksum fn should be function");return{encode(n){if(!(n instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const r=e(n).slice(0,t),o=new Uint8Array(n.length+t);return o.set(n),o.set(r,n.length),o},decode(n){if(!(n instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-t),o=e(r).slice(0,t),i=n.slice(-t);for(let s=0;s<t;s++)if(o[s]!==i[s])throw new Error("Invalid checksum");return r}}}const ws=vt(Mt(4),It("0123456789ABCDEF"),Tt("")),ys=vt(Mt(5),It("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),je(5),Tt(""));vt(Mt(5),It("0123456789ABCDEFGHIJKLMNOPQRSTUV"),je(5),Tt(""));vt(Mt(5),It("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),Tt(""),uo(t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const bs=vt(Mt(6),It("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),je(6),Tt("")),ms=vt(Mt(6),It("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),je(6),Tt("")),Qn=t=>vt(ps(58),It(t),Tt("")),Ce=Qn("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");Qn("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");Qn("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const wr=[0,2,3,5,6,7,9,10,11],Es={encode(t){let e="";for(let n=0;n<t.length;n+=8){const r=t.subarray(n,n+8);e+=Ce.encode(r).padStart(wr[r.length],"1")}return e},decode(t){let e=[];for(let n=0;n<t.length;n+=11){const r=t.slice(n,n+11),o=wr.indexOf(r.length),i=Ce.decode(r);for(let s=0;s<i.length-o;s++)if(i[s]!==0)throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(i.slice(i.length-o)))}return Uint8Array.from(e)}},xs=t=>vt(gs(4,e=>t(t(e))),Ce),An=vt(It("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Tt("")),yr=[996825010,642813549,513874426,1027748829,705979059];function de(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<yr.length;r++)(e>>r&1)===1&&(n^=yr[r]);return n}function br(t,e,n=1){const r=t.length;let o=1;for(let i=0;i<r;i++){const s=t.charCodeAt(i);if(s<33||s>126)throw new Error(`Invalid prefix (${t})`);o=de(o)^s>>5}o=de(o);for(let i=0;i<r;i++)o=de(o)^t.charCodeAt(i)&31;for(let i of e)o=de(o)^i;for(let i=0;i<6;i++)o=de(o);return o^=n,An.encode(vn([o%2**30],30,5,!1))}function po(t){const e=t==="bech32"?1:734539939,n=Mt(5),r=n.decode,o=n.encode,i=gr(r);function s(u,l,d=90){if(typeof u!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof u}`);if(!Array.isArray(l)||l.length&&typeof l[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);const p=u.length+7+l.length;if(d!==!1&&p>d)throw new TypeError(`Length ${p} exceeds limit ${d}`);return u=u.toLowerCase(),`${u}1${An.encode(l)}${br(u,l,e)}`}function c(u,l=90){if(typeof u!="string")throw new Error(`bech32.decode input should be string, not ${typeof u}`);if(u.length<8||l!==!1&&u.length>l)throw new TypeError(`Wrong string length: ${u.length} (${u}). Expected (8..${l})`);const d=u.toLowerCase();if(u!==d&&u!==u.toUpperCase())throw new Error("String must be lowercase or uppercase");u=d;const p=u.lastIndexOf("1");if(p===0||p===-1)throw new Error('Letter "1" must be present between prefix and data only');const y=u.slice(0,p),h=u.slice(p+1);if(h.length<6)throw new Error("Data must be at least 6 characters long");const g=An.decode(h).slice(0,-6),w=br(y,g,e);if(!h.endsWith(w))throw new Error(`Invalid checksum in ${u}: expected "${w}"`);return{prefix:y,words:g}}const a=gr(c);function f(u){const{prefix:l,words:d}=c(u,!1);return{prefix:l,words:d,bytes:r(d)}}return{encode:s,decode:c,decodeToBytes:f,decodeUnsafe:a,fromWords:r,fromWordsUnsafe:i,toWords:o}}const kn=po("bech32"),go=po("bech32m"),In={encode:t=>new TextDecoder().decode(t),decode:t=>new TextEncoder().encode(t)},V=vt(Mt(4),It("0123456789abcdef"),Tt(""),uo(t=>{if(typeof t!="string"||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),Ss={utf8:In,hex:V,base16:ws,base32:ys,base64:bs,base64url:ms,base58:Ce,base58xmr:Es};`${Object.keys(Ss).join(", ")}`;const _=new Uint8Array,Fn=new Uint8Array([0]);function H(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Tn(...t){if(t.length===1)return t[0];const e=t.reduce((r,o)=>r+o.length,0),n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const i=t[r];n.set(i,o),o+=i.length}return n}const dt=t=>t instanceof Uint8Array;class wo{constructor(e,n=[],r=[]){this.data=e,this.path=n,this.fieldPath=r,this.pos=0,this.hasPtr=!1,this.bitBuf=0,this.bitPos=0}err(e){return new Error(`Reader(${this.fieldPath.join("/")}): ${e}`)}absBytes(e){if(e>this.data.length)throw new Error("absBytes: Unexpected end of buffer");return this.data.subarray(e)}bytes(e,n=!1){if(this.bitPos)throw this.err("readBytes: bitPos not empty");if(!Number.isFinite(e))throw this.err(`readBytes: wrong length=${e}`);if(this.pos+e>this.data.length)throw this.err("readBytes: Unexpected end of buffer");const r=this.data.subarray(this.pos,this.pos+e);return n||(this.pos+=e),r}byte(e=!1){if(this.bitPos)throw this.err("readByte: bitPos not empty");return this.data[e?this.pos:this.pos++]}get leftBytes(){return this.data.length-this.pos}isEnd(){return this.pos>=this.data.length&&!this.bitPos}length(e){let n;if(Ot(e)?n=Number(e.decodeStream(this)):typeof e=="number"?n=e:typeof e=="string"&&(n=He(this.path,e.split("/"))),typeof n=="bigint"&&(n=Number(n)),typeof n!="number")throw this.err(`Wrong length: ${n}`);return n}bits(e){if(e>32)throw this.err("BitReader: cannot read more than 32 bits in single call");let n=0;for(;e;){this.bitPos||(this.bitBuf=this.data[this.pos++],this.bitPos=8);const r=Math.min(e,this.bitPos);this.bitPos-=r,n=n<<r|this.bitBuf>>this.bitPos&2**r-1,this.bitBuf&=2**this.bitPos-1,e-=r}return n>>>0}find(e,n=this.pos){if(!dt(e))throw this.err(`find: needle is not bytes! ${e}`);if(this.bitPos)throw this.err("findByte: bitPos not empty");if(!e.length)throw this.err("find: needle is empty");for(let r=n;(r=this.data.indexOf(e[0],r))!==-1;r++){if(r===-1||this.data.length-r<e.length)return;if(H(e,this.data.subarray(r,r+e.length)))return r}}finish(){if(!(this.isEnd()||this.hasPtr))throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${V.encode(this.data.slice(this.pos))}`)}fieldPathPush(e){this.fieldPath.push(e)}fieldPathPop(){this.fieldPath.pop()}}class yo{constructor(e=[],n=[]){this.path=e,this.fieldPath=n,this.buffers=[],this.pos=0,this.ptrs=[],this.bitBuf=0,this.bitPos=0}err(e){return new Error(`Writer(${this.fieldPath.join("/")}): ${e}`)}bytes(e){if(this.bitPos)throw this.err("writeBytes: ends with non-empty bit buffer");this.buffers.push(e),this.pos+=e.length}byte(e){if(this.bitPos)throw this.err("writeByte: ends with non-empty bit buffer");this.buffers.push(new Uint8Array([e])),this.pos++}get buffer(){if(this.bitPos)throw this.err("buffer: ends with non-empty bit buffer");let e=Tn(...this.buffers);for(let n of this.ptrs){const r=e.length;e=Tn(e,n.buffer);const o=n.ptr.encode(r);for(let i=0;i<o.length;i++)e[n.pos+i]=o[i]}return e}length(e,n){if(e===null)return;if(Ot(e))return e.encodeStream(this,n);let r;if(typeof e=="number"?r=e:typeof e=="string"&&(r=He(this.path,e.split("/"))),typeof r=="bigint"&&(r=Number(r)),r===void 0||r!==n)throw this.err(`Wrong length: ${r} len=${e} exp=${n}`)}bits(e,n){if(n>32)throw this.err("writeBits: cannot write more than 32 bits in single call");if(e>=2**n)throw this.err(`writeBits: value (${e}) >= 2**bits (${n})`);for(;n;){const r=Math.min(n,8-this.bitPos);this.bitBuf=this.bitBuf<<r|e>>n-r,this.bitPos+=r,n-=r,e&=2**n-1,this.bitPos===8&&(this.bitPos=0,this.buffers.push(new Uint8Array([this.bitBuf])),this.pos++)}}fieldPathPush(e){this.fieldPath.push(e)}fieldPathPop(){this.fieldPath.pop()}}const _e=t=>Uint8Array.from(t).reverse();function mr(t,e,n,r){if(r){const o=2n**(n-1n);if(e<-o||e>=o)throw t.err("sInt: value out of bounds")}else if(0n>e||e>=2n**n)throw t.err("uInt: value out of bounds")}function Y(t){return{...t,encode:e=>{const n=new yo;return t.encodeStream(n,e),n.buffer},decode:e=>{const n=new wo(e),r=t.decodeStream(n);return n.finish(),r}}}function He(t,e){t=Array.from(t);let n=0;for(;n<e.length&&e[n]==="..";n++)t.pop();let r=t.pop();for(;n<e.length;n++){if(!r||r[e[n]]===void 0)return;r=r[e[n]]}return r}function Ot(t){return typeof t.encode=="function"&&typeof t.encodeStream=="function"&&typeof t.decode=="function"&&typeof t.decodeStream=="function"}function vs(){return{encode:t=>{const e={};for(const[n,r]of t){if(e[n]!==void 0)throw new Error(`coders.dict: same key(${n}) appears twice in struct`);e[n]=r}return e},decode:t=>Object.entries(t)}}const As={encode:t=>{if(t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${t}`);return Number(t)},decode:t=>BigInt(t)};function ks(t){return{encode:e=>t[e],decode:e=>t[e]}}function Is(t){const e=10n**BigInt(t);return{encode:n=>{let r=(n<0n?-n:n).toString(10),o=r.length-t;o<0&&(r=r.padStart(r.length-o,"0"),o=0);let i=r.length-1;for(;i>=o&&r[i]==="0";i--);let[s,c]=[r.slice(0,o),r.slice(o,i+1)];return s||(s="0"),n<0n&&(s="-"+s),c?`${s}.${c}`:s},decode:n=>{let r=!1;n.startsWith("-")&&(r=!0,n=n.slice(1));let o=n.indexOf(".");o=o===-1?n.length:o;const[i,s]=[n.slice(0,o),n.slice(o+1)],c=BigInt(i)*e,a=Math.min(s.length,t),f=BigInt(s.slice(0,a))*10n**BigInt(t-a),u=c+f;return r?-u:u}}}function Ts(t){return{encode:e=>{for(const n of t){const r=n.encode(e);if(r!==void 0)return r}throw new Error(`match/encode: cannot find match in ${e}`)},decode:e=>{for(const n of t){const r=n.decode(e);if(r!==void 0)return r}throw new Error(`match/decode: cannot find match in ${e}`)}}}const ue={dict:vs,number:As,tsEnum:ks,decimal:Is,match:Ts},lt=(t,e=!1,n=!1)=>Y({size:t,encodeStream:(r,o)=>{if(typeof o!="number"&&typeof o!="bigint")throw r.err(`bigint: invalid value: ${o}`);let i=BigInt(o);const s=BigInt(t);mr(r,i,8n*s,!!n);const c=2n**(8n*s-1n);n&&i<0&&(i=i|c);let a=[];for(let u=0;u<t;u++)a.push(Number(i&255n)),i>>=8n;let f=new Uint8Array(a).reverse();r.bytes(e?f.reverse():f)},decodeStream:r=>{const o=BigInt(t);let i=r.bytes(t);e&&(i=_e(i));const s=_e(i),c=2n**(8n*o-1n);let a=0n;for(let f=0;f<s.length;f++)a|=BigInt(s[f])<<8n*BigInt(f);return n&&a&c&&(a=(a^c)-c),mr(r,a,8n*o,!!n),a}});lt(32,!0);const Bs=lt(32,!1);lt(32,!0,!0);lt(32,!1,!0);lt(16,!0);lt(16,!1);lt(16,!0,!0);lt(16,!1,!0);const Ie=lt(8,!0);lt(8,!1);const $s=lt(8,!0,!0);lt(8,!1,!0);const At=(t,e=!1,n=!1)=>{if(t>6)throw new Error("int supports size up to 6 bytes (48 bits), for other use bigint");return Ee(lt(t,e,n),ue.number)},L=At(4,!0),Us=At(4,!1),ge=At(4,!0,!0);At(4,!1,!0);const Er=At(2,!0);At(2,!1);At(2,!0,!0);At(2,!1,!0);const qt=At(1,!1);At(1,!1,!0);Y({size:1,encodeStream:(t,e)=>t.byte(e?1:0),decodeStream:t=>{const e=t.byte();if(e!==0&&e!==1)throw t.err(`bool: invalid value ${e}`);return e===1}});const W=(t,e=!1)=>Y({size:typeof t=="number"?t:void 0,encodeStream:(n,r)=>{if(!dt(r))throw n.err(`bytes: invalid value ${r}`);dt(t)||n.length(t,r.length),n.bytes(e?_e(r):r),dt(t)&&n.bytes(t)},decodeStream:n=>{let r;if(dt(t)){const o=n.find(t);if(!o)throw n.err("bytes: cannot find terminator");r=n.bytes(o-n.pos),n.bytes(t.length)}else r=n.bytes(t===null?n.leftBytes:n.length(t));return e?_e(r):r}}),Ze=(t,e=!1)=>{const n=W(t,e);return Y({size:n.size,encodeStream:(r,o)=>n.encodeStream(r,In.decode(o)),decodeStream:r=>In.encode(n.decodeStream(r))})};Ze(Fn);const Ls=(t,e=!1,n=!1)=>{const r=W(t,e);return Y({size:r.size,encodeStream:(o,i)=>{if(n&&!i.startsWith("0x"))throw new Error("hex(withZero=true).encode input should start with 0x");const s=V.decode(n?i.slice(2):i);return r.encodeStream(o,s)},decodeStream:o=>(n?"0x":"")+V.encode(r.decodeStream(o))})};function Ee(t,e){if(!Ot(t))throw new Error(`apply: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(n,r)=>{let o;try{o=e.decode(r)}catch(i){throw n.err(""+i)}return t.encodeStream(n,o)},decodeStream:n=>{const r=t.decodeStream(n);try{return e.encode(r)}catch(o){throw n.err(""+o)}}})}function bt(t,e){if(!Ot(t))throw new Error(`validate: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(n,r)=>t.encodeStream(n,e(r)),decodeStream:n=>e(t.decodeStream(n))})}const Rs=(t,e=!1)=>Y({size:t.length,encodeStream:(n,r)=>{!!r!==e&&n.bytes(t)},decodeStream:n=>{let r=n.leftBytes>=t.length;return r&&(r=H(n.bytes(t.length,!0),t),r&&n.bytes(t.length)),r!==e}});function Ns(t,e,n){if(!Ot(e))throw new Error(`flagged: invalid inner value ${e}`);return Y({encodeStream:(r,o)=>{typeof t=="string"?He(r.path,t.split("/"))?e.encodeStream(r,o):n&&e.encodeStream(r,n):(t.encodeStream(r,!!o),o?e.encodeStream(r,o):n&&e.encodeStream(r,n))},decodeStream:r=>{let o=!1;if(typeof t=="string"?o=He(r.path,t.split("/")):o=t.decodeStream(r),o)return e.decodeStream(r);n&&e.decodeStream(r)}})}function Qe(t,e,n=!0){if(!Ot(t))throw new Error(`flagged: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(r,o)=>t.encodeStream(r,e),decodeStream:r=>{const o=t.decodeStream(r);if(n&&typeof o!="object"&&o!==e||dt(e)&&!H(e,o))throw r.err(`magic: invalid value: ${o} !== ${e}`)}})}function bo(t){let e=0;for(let n of t){if(!n.size)return;e+=n.size}return e}function nt(t){if(Array.isArray(t))throw new Error("Packed.Struct: got array instead of object");return Y({size:bo(Object.values(t)),encodeStream:(e,n)=>{if(typeof n!="object"||n===null)throw e.err(`struct: invalid value ${n}`);e.path.push(n);for(let r in t)e.fieldPathPush(r),t[r].encodeStream(e,n[r]),e.fieldPathPop();e.path.pop()},decodeStream:e=>{let n={};e.path.push(n);for(let r in t)e.fieldPathPush(r),n[r]=t[r].decodeStream(e),e.fieldPathPop();return e.path.pop(),n}})}function Cs(t){if(!Array.isArray(t))throw new Error(`Packed.Tuple: got ${typeof t} instead of array`);return Y({size:bo(t),encodeStream:(e,n)=>{if(!Array.isArray(n))throw e.err(`tuple: invalid value ${n}`);e.path.push(n);for(let r=0;r<t.length;r++)e.fieldPathPush(""+r),t[r].encodeStream(e,n[r]),e.fieldPathPop();e.path.pop()},decodeStream:e=>{let n=[];e.path.push(n);for(let r=0;r<t.length;r++)e.fieldPathPush(""+r),n.push(t[r].decodeStream(e)),e.fieldPathPop();return e.path.pop(),n}})}function _s(t,e){if(!Ot(e))throw new Error(`prefix: invalid inner value ${e}`);if(dt(t))throw new Error("prefix: len cannot be Uint8Array");const n=W(t);return Y({size:typeof t=="number"?t:void 0,encodeStream:(r,o)=>{const i=new yo(r.path,r.fieldPath);e.encodeStream(i,o),n.encodeStream(r,i.buffer)},decodeStream:r=>{const o=n.decodeStream(r);return e.decodeStream(new wo(o,r.path,r.fieldPath))}})}function rt(t,e){if(!Ot(e))throw new Error(`array: invalid inner value ${e}`);return Y({size:typeof t=="number"&&e.size?t*e.size:void 0,encodeStream:(n,r)=>{if(!Array.isArray(r))throw n.err(`array: invalid value ${r}`);dt(t)||n.length(t,r.length),n.path.push(r);for(let o=0;o<r.length;o++){n.fieldPathPush(""+o);const i=r[o],s=n.pos;if(e.encodeStream(n,i),dt(t)){if(t.length>n.pos-s)continue;const c=n.buffer.subarray(s,n.pos);if(H(c.subarray(0,t.length),t))throw n.err(`array: inner element encoding same as separator. elm=${i} data=${c}`)}n.fieldPathPop()}n.path.pop(),dt(t)&&n.bytes(t)},decodeStream:n=>{let r=[];if(t===null){let o=0;for(n.path.push(r);!n.isEnd()&&(n.fieldPathPush(""+o++),r.push(e.decodeStream(n)),n.fieldPathPop(),!(e.size&&n.leftBytes<e.size)););n.path.pop()}else if(dt(t)){let o=0;for(n.path.push(r);;){if(H(n.bytes(t.length,!0),t)){n.bytes(t.length);break}n.fieldPathPush(""+o++),r.push(e.decodeStream(n)),n.fieldPathPop()}n.path.pop()}else{n.fieldPathPush("arrayLen");const o=n.length(t);n.fieldPathPop(),n.path.push(r);for(let i=0;i<o;i++)n.fieldPathPush(""+i),r.push(e.decodeStream(n)),n.fieldPathPop();n.path.pop()}return r}})}Qe(W(0),_);/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{ProjectivePoint:Fe,sign:xr,getPublicKey:mo}=le,De=le.CURVE.n,we=(t,e)=>t===void 0?e:t,D=dt,Xe=t=>ds(wt(t)),Ht=(...t)=>wt(wt(Wt(...t))),Wt=Tn,Eo=xs(wt);function We(t){if(Array.isArray(t))return t.map(e=>We(e));if(t instanceof Uint8Array)return Uint8Array.from(t);if(["number","bigint","boolean","string","undefined"].includes(typeof t))return t;if(t===null)return t;if(typeof t=="object")return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,We(n)]));throw new Error(`cloneDeep: unknown type=${t} (${typeof t})`)}var Z;(function(t){t[t.ecdsa=0]="ecdsa",t[t.schnorr=1]="schnorr"})(Z||(Z={}));function ce(t,e){const n=t.length;if(e===Z.ecdsa){if(n===32)throw new Error("Expected non-Schnorr key");return Fe.fromHex(t),t}else if(e===Z.schnorr){if(n!==32)throw new Error("Expected 32-byte Schnorr key");return ft.utils.lift_x(ft.utils.bytesToNumberBE(t)),t}else throw new Error("Unknown key type")}function Kt(t,e){try{return ce(t,e),!0}catch{return!1}}const Sr=t=>t.r<De/2n;function Hs(t,e,n=!1){let r=xr(t,e);if(n&&!Sr(r)){const o=new Uint8Array(32);for(let i=0;i<Number.MAX_SAFE_INTEGER&&(o.set(L.encode(i)),r=xr(t,e,{extraEntropy:o}),!Sr(r));i++);}return r.toDERRawBytes()}function xo(t,e){const n=ft.utils,r=n.taggedHash("TapTweak",t,e),o=n.bytesToNumberBE(r);if(o>=De)throw new Error("tweak higher than curve order");return o}function Ds(t,e=new Uint8Array){const n=ft.utils,r=n.bytesToNumberBE(t),o=Fe.fromPrivateKey(r),i=o.hasEvenY()?r:n.mod(-r,De),s=n.pointToBytes(o),c=xo(s,e);return n.numberToBytesBE(n.mod(i+c,De),32)}function So(t,e){const n=ft.utils,r=xo(t,e),i=n.lift_x(n.bytesToNumberBE(t)).add(Fe.fromPrivateKey(r)),s=i.hasEvenY()?0:1;return[n.pointToBytes(i),s]}const Bn=bt(W(null),t=>ce(t,Z.ecdsa)),Ve=bt(W(32),t=>ce(t,Z.schnorr)),vr=bt(W(null),t=>{if(t.length!==64&&t.length!==65)throw new Error("Schnorr signature should be 64 or 65 bytes long");return t}),Xt={bech32:"bc",pubKeyHash:0,scriptHash:5,wif:128},Nc={bech32:"tb",pubKeyHash:111,scriptHash:196,wif:239},Ws=8,Vs=2,Yt=0,vo=4294967295,Ae=new Uint8Array(32);ue.decimal(Ws);function $n(t,e){if(!D(t)||!D(e))throw new Error(`cmp: wrong type a=${typeof t} b=${typeof e}`);const n=Math.min(t.length,e.length);for(let r=0;r<n;r++)if(t[r]!=e[r])return Math.sign(t[r]-e[r]);return Math.sign(t.length-e.length)}var z;(function(t){t[t.OP_0=0]="OP_0",t[t.PUSHDATA1=76]="PUSHDATA1",t[t.PUSHDATA2=77]="PUSHDATA2",t[t.PUSHDATA4=78]="PUSHDATA4",t[t["1NEGATE"]=79]="1NEGATE",t[t.RESERVED=80]="RESERVED",t[t.OP_1=81]="OP_1",t[t.OP_2=82]="OP_2",t[t.OP_3=83]="OP_3",t[t.OP_4=84]="OP_4",t[t.OP_5=85]="OP_5",t[t.OP_6=86]="OP_6",t[t.OP_7=87]="OP_7",t[t.OP_8=88]="OP_8",t[t.OP_9=89]="OP_9",t[t.OP_10=90]="OP_10",t[t.OP_11=91]="OP_11",t[t.OP_12=92]="OP_12",t[t.OP_13=93]="OP_13",t[t.OP_14=94]="OP_14",t[t.OP_15=95]="OP_15",t[t.OP_16=96]="OP_16",t[t.NOP=97]="NOP",t[t.VER=98]="VER",t[t.IF=99]="IF",t[t.NOTIF=100]="NOTIF",t[t.VERIF=101]="VERIF",t[t.VERNOTIF=102]="VERNOTIF",t[t.ELSE=103]="ELSE",t[t.ENDIF=104]="ENDIF",t[t.VERIFY=105]="VERIFY",t[t.RETURN=106]="RETURN",t[t.TOALTSTACK=107]="TOALTSTACK",t[t.FROMALTSTACK=108]="FROMALTSTACK",t[t["2DROP"]=109]="2DROP",t[t["2DUP"]=110]="2DUP",t[t["3DUP"]=111]="3DUP",t[t["2OVER"]=112]="2OVER",t[t["2ROT"]=113]="2ROT",t[t["2SWAP"]=114]="2SWAP",t[t.IFDUP=115]="IFDUP",t[t.DEPTH=116]="DEPTH",t[t.DROP=117]="DROP",t[t.DUP=118]="DUP",t[t.NIP=119]="NIP",t[t.OVER=120]="OVER",t[t.PICK=121]="PICK",t[t.ROLL=122]="ROLL",t[t.ROT=123]="ROT",t[t.SWAP=124]="SWAP",t[t.TUCK=125]="TUCK",t[t.CAT=126]="CAT",t[t.SUBSTR=127]="SUBSTR",t[t.LEFT=128]="LEFT",t[t.RIGHT=129]="RIGHT",t[t.SIZE=130]="SIZE",t[t.INVERT=131]="INVERT",t[t.AND=132]="AND",t[t.OR=133]="OR",t[t.XOR=134]="XOR",t[t.EQUAL=135]="EQUAL",t[t.EQUALVERIFY=136]="EQUALVERIFY",t[t.RESERVED1=137]="RESERVED1",t[t.RESERVED2=138]="RESERVED2",t[t["1ADD"]=139]="1ADD",t[t["1SUB"]=140]="1SUB",t[t["2MUL"]=141]="2MUL",t[t["2DIV"]=142]="2DIV",t[t.NEGATE=143]="NEGATE",t[t.ABS=144]="ABS",t[t.NOT=145]="NOT",t[t["0NOTEQUAL"]=146]="0NOTEQUAL",t[t.ADD=147]="ADD",t[t.SUB=148]="SUB",t[t.MUL=149]="MUL",t[t.DIV=150]="DIV",t[t.MOD=151]="MOD",t[t.LSHIFT=152]="LSHIFT",t[t.RSHIFT=153]="RSHIFT",t[t.BOOLAND=154]="BOOLAND",t[t.BOOLOR=155]="BOOLOR",t[t.NUMEQUAL=156]="NUMEQUAL",t[t.NUMEQUALVERIFY=157]="NUMEQUALVERIFY",t[t.NUMNOTEQUAL=158]="NUMNOTEQUAL",t[t.LESSTHAN=159]="LESSTHAN",t[t.GREATERTHAN=160]="GREATERTHAN",t[t.LESSTHANOREQUAL=161]="LESSTHANOREQUAL",t[t.GREATERTHANOREQUAL=162]="GREATERTHANOREQUAL",t[t.MIN=163]="MIN",t[t.MAX=164]="MAX",t[t.WITHIN=165]="WITHIN",t[t.RIPEMD160=166]="RIPEMD160",t[t.SHA1=167]="SHA1",t[t.SHA256=168]="SHA256",t[t.HASH160=169]="HASH160",t[t.HASH256=170]="HASH256",t[t.CODESEPARATOR=171]="CODESEPARATOR",t[t.CHECKSIG=172]="CHECKSIG",t[t.CHECKSIGVERIFY=173]="CHECKSIGVERIFY",t[t.CHECKMULTISIG=174]="CHECKMULTISIG",t[t.CHECKMULTISIGVERIFY=175]="CHECKMULTISIGVERIFY",t[t.NOP1=176]="NOP1",t[t.CHECKLOCKTIMEVERIFY=177]="CHECKLOCKTIMEVERIFY",t[t.CHECKSEQUENCEVERIFY=178]="CHECKSEQUENCEVERIFY",t[t.NOP4=179]="NOP4",t[t.NOP5=180]="NOP5",t[t.NOP6=181]="NOP6",t[t.NOP7=182]="NOP7",t[t.NOP8=183]="NOP8",t[t.NOP9=184]="NOP9",t[t.NOP10=185]="NOP10",t[t.CHECKSIGADD=186]="CHECKSIGADD",t[t.INVALID=255]="INVALID"})(z||(z={}));const F=Y({encodeStream:(t,e)=>{for(let n of e){if(typeof n=="string"){if(z[n]===void 0)throw new Error(`Unknown opcode=${n}`);t.byte(z[n]);continue}else if(typeof n=="number"){if(n===0){t.byte(0);continue}else if(1<=n&&n<=16){t.byte(z.OP_1-1+n);continue}}if(typeof n=="number"&&(n=Ao().encode(BigInt(n))),!D(n))throw new Error(`Wrong Script OP=${n} (${typeof n})`);const r=n.length;r<z.PUSHDATA1?t.byte(r):r<=255?(t.byte(z.PUSHDATA1),t.byte(r)):r<=65535?(t.byte(z.PUSHDATA2),t.bytes(Er.encode(r))):(t.byte(z.PUSHDATA4),t.bytes(L.encode(r))),t.bytes(n)}},decodeStream:t=>{const e=[];for(;!t.isEnd();){const n=t.byte();if(z.OP_0<n&&n<=z.PUSHDATA4){let r;if(n<z.PUSHDATA1)r=n;else if(n===z.PUSHDATA1)r=qt.decodeStream(t);else if(n===z.PUSHDATA2)r=Er.decodeStream(t);else if(n===z.PUSHDATA4)r=L.decodeStream(t);else throw new Error("Should be not possible");e.push(t.bytes(r))}else if(n===0)e.push(0);else if(z.OP_1<=n&&n<=z.OP_16)e.push(n-(z.OP_1-1));else{const r=z[n];if(r===void 0)throw new Error(`Unknown opcode=${n.toString(16)}`);e.push(r)}}return e}});function Ao(t=6,e=!1){return Y({encodeStream:(n,r)=>{if(r===0n)return;const o=r<0,i=BigInt(r),s=[];for(let c=o?-i:i;c;c>>=8n)s.push(Number(c&0xffn));s[s.length-1]>=128?s.push(o?128:0):o&&(s[s.length-1]|=128),n.bytes(new Uint8Array(s))},decodeStream:n=>{const r=n.leftBytes;if(r>t)throw new Error(`ScriptNum: number (${r}) bigger than limit=${t}`);if(r===0)return 0n;if(e&&!(n.data[r-1]&127)&&(r<=1||!(n.data[r-2]&128)))throw new Error("Non-minimally encoded ScriptNum");let o=0,i=0n;for(let s=0;s<r;++s)o=n.byte(),i|=BigInt(o)<<8n*BigInt(s);return o>=128&&(i&=2n**BigInt(r*8)-1n>>1n,i=-i),i}})}function Ks(t,e=4,n=!0){if(typeof t=="number")return t;if(D(t))try{const r=Ao(e,n).decode(t);return r>Number.MAX_SAFE_INTEGER?void 0:Number(r)}catch{return}}const Ar={253:[253,2,253n,65535n],254:[254,4,65536n,4294967295n],255:[255,8,4294967296n,18446744073709551615n]},Je=Y({encodeStream:(t,e)=>{if(typeof e=="number"&&(e=BigInt(e)),0n<=e&&e<=252n)return t.byte(Number(e));for(const[n,r,o,i]of Object.values(Ar))if(!(o>e||e>i)){t.byte(n);for(let s=0;s<r;s++)t.byte(Number(e>>8n*BigInt(s)&0xffn));return}throw t.err(`VarInt too big: ${e}`)},decodeStream:t=>{const e=t.byte();if(e<=252)return BigInt(e);const[n,r,o]=Ar[e];let i=0n;for(let s=0;s<r;s++)i|=BigInt(t.byte())<<8n*BigInt(s);if(i<o)throw t.err(`Wrong CompactSize(${8*r})`);return i}}),yt=Ee(Je,ue.number),kr=t=>rt(Je,t),pt=W(Je),Ps=nt({txid:W(32,!0),index:L,finalScriptSig:pt,sequence:L}),re=nt({amount:Ie,script:pt}),qs={amount:0xffffffffffffffffn,script:_},Xn=rt(yt,pt),zs=nt({version:ge,segwitFlag:Rs(new Uint8Array([0,1])),inputs:kr(Ps),outputs:kr(re),witnesses:Ns("segwitFlag",rt("inputs/length",Xn)),lockTime:L});function Ms(t){if(t.segwitFlag&&t.witnesses&&!t.witnesses.length)throw new Error("Segwit flag with empty witnesses array");return t}const St=bt(zs,Ms);function Un(t){const[e,n,r,o,i,s]=t;return{type:e,kc:n,vc:r,reqInc:o,allowInc:i,silentIgnore:s}}const tn=nt({fingerprint:Us,path:rt(null,L)}),Os=nt({version:qt,internalKey:W(32),merklePath:rt(null,W(32))}),oe=bt(Os,t=>{if(t.merklePath.length>128)throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");return t}),ko=nt({hashes:rt(yt,W(32)),der:tn}),Gs=W(78),Ys=nt({pubKey:Ve,leafHash:W(32)}),js=rt(null,nt({depth:qt,version:qt,script:pt})),M=W(null),Ir=W(20),pe=W(32),Jn={unsignedTx:[0,!1,St,[0],[0],!1],xpub:[1,Gs,tn,[],[0,2],!1],txVersion:[2,!1,L,[2],[2],!1],fallbackLocktime:[3,!1,L,[],[2],!1],inputCount:[4,!1,yt,[2],[2],!1],outputCount:[5,!1,yt,[2],[2],!1],txModifiable:[6,!1,qt,[],[2],!1],version:[251,!1,L,[],[0,2],!1],proprietary:[252,M,M,[],[0,2],!1]},Ke={nonWitnessUtxo:[0,!1,St,[],[0,2],!1],witnessUtxo:[1,!1,re,[],[0,2],!1],partialSig:[2,Bn,M,[],[0,2],!1],sighashType:[3,!1,L,[],[0,2],!1],redeemScript:[4,!1,M,[],[0,2],!1],witnessScript:[5,!1,M,[],[0,2],!1],bip32Derivation:[6,Bn,tn,[],[0,2],!1],finalScriptSig:[7,!1,M,[],[0,2],!1],finalScriptWitness:[8,!1,Xn,[],[0,2],!1],porCommitment:[9,!1,M,[],[0,2],!1],ripemd160:[10,Ir,M,[],[0,2],!1],sha256:[11,pe,M,[],[0,2],!1],hash160:[12,Ir,M,[],[0,2],!1],hash256:[13,pe,M,[],[0,2],!1],txid:[14,!1,pe,[2],[2],!0],index:[15,!1,L,[2],[2],!0],sequence:[16,!1,L,[],[2],!0],requiredTimeLocktime:[17,!1,L,[],[2],!1],requiredHeightLocktime:[18,!1,L,[],[2],!1],tapKeySig:[19,!1,vr,[],[0,2],!1],tapScriptSig:[20,Ys,vr,[],[0,2],!1],tapLeafScript:[21,oe,M,[],[0,2],!1],tapBip32Derivation:[22,pe,ko,[],[0,2],!1],tapInternalKey:[23,!1,Ve,[],[0,2],!1],tapMerkleRoot:[24,!1,pe,[],[0,2],!1],proprietary:[252,M,M,[],[0,2],!1]},Zs=["txid","sequence","index","witnessUtxo","nonWitnessUtxo","finalScriptSig","finalScriptWitness","unknown"],Qs=["partialSig","finalScriptSig","finalScriptWitness","tapKeySig","tapScriptSig"],Pe={redeemScript:[0,!1,M,[],[0,2],!1],witnessScript:[1,!1,M,[],[0,2],!1],bip32Derivation:[2,Bn,tn,[],[0,2],!1],amount:[3,!1,$s,[2],[2],!0],script:[4,!1,M,[2],[2],!0],tapInternalKey:[5,!1,Ve,[],[0,2],!1],tapTree:[6,!1,js,[],[0,2],!1],tapBip32Derivation:[7,Ve,ko,[],[0,2],!1],proprietary:[252,M,M,[],[0,2],!1]},Fs=[],Tr=rt(Fn,nt({key:_s(yt,nt({type:yt,key:W(null)})),value:W(yt)}));nt({type:yt,key:W(null)});function tr(t){const e={};for(const n in t){const[r,o,i]=t[n];e[r]=[n,o,i]}return Y({encodeStream:(n,r)=>{let o=[];for(const i in t){const s=r[i];if(s===void 0)continue;const[c,a,f]=t[i];if(!a)o.push({key:{type:c,key:_},value:f.encode(s)});else{const u=s.map(([l,d])=>[a.encode(l),f.encode(d)]);u.sort((l,d)=>$n(l[0],d[0]));for(const[l,d]of u)o.push({key:{key:l,type:c},value:d})}}if(r.unknown){r.unknown.sort((i,s)=>$n(i[0].key,s[0].key));for(const[i,s]of r.unknown)o.push({key:i,value:s})}Tr.encodeStream(n,o)},decodeStream:n=>{const r=Tr.decodeStream(n),o={},i={};for(const s of r){let c="unknown",a=s.key.key,f=s.value;if(e[s.key.type]){const[u,l,d]=e[s.key.type];if(c=u,!l&&a.length)throw new Error(`PSBT: Non-empty key for ${c} (key=${V.encode(a)} value=${V.encode(f)}`);if(a=l?l.decode(a):void 0,f=d.decode(f),!l){if(o[c])throw new Error(`PSBT: Same keys: ${c} (key=${a} value=${f})`);o[c]=f,i[c]=!0;continue}}else a={type:s.key.type,key:s.key.key};if(i[c])throw new Error(`PSBT: Key type with empty key and no key=${c} val=${f}`);o[c]||(o[c]=[]),o[c].push([a,f])}return o}})}function Br(t,e){if(!H(t.hash,wt(e)))throw new Error("checkScript: wsh wrong witnessScript hash");const n=X.decode(e);if(n.type==="tr"||n.type==="tr_ns"||n.type==="tr_ms")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`);if(n.type==="wpkh"||n.type==="sh")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`)}function $r(t,e,n){if(t){const r=X.decode(t);if(r.type==="tr_ns"||r.type==="tr_ms"||r.type==="ms"||r.type=="pk")throw new Error(`checkScript: non-wrapped ${r.type}`);if(r.type==="sh"&&e){if(!H(r.hash,Xe(e)))throw new Error("checkScript: sh wrong redeemScript hash");const o=X.decode(e);if(o.type==="tr"||o.type==="tr_ns"||o.type==="tr_ms")throw new Error(`checkScript: P2${o.type} cannot be wrapped in P2SH`);if(o.type==="sh")throw new Error("checkScript: P2SH cannot be wrapped in P2SH")}r.type==="wsh"&&n&&Br(r,n)}if(e){const r=X.decode(e);r.type==="wsh"&&n&&Br(r,n)}}const er=bt(tr(Ke),t=>{if(t.finalScriptWitness&&!t.finalScriptWitness.length)throw new Error("validateInput: wmpty finalScriptWitness");if(t.partialSig&&!t.partialSig.length)throw new Error("Empty partialSig");if(t.partialSig)for(const[e,n]of t.partialSig)ce(e,Z.ecdsa);if(t.bip32Derivation)for(const[e,n]of t.bip32Derivation)ce(e,Z.ecdsa);if(t.requiredTimeLocktime!==void 0&&t.requiredTimeLocktime<5e8)throw new Error(`validateInput: wrong timeLocktime=${t.requiredTimeLocktime}`);if(t.requiredHeightLocktime!==void 0&&(t.requiredHeightLocktime<=0||t.requiredHeightLocktime>=5e8))throw new Error(`validateInput: wrong heighLocktime=${t.requiredHeightLocktime}`);if(t.nonWitnessUtxo&&t.index!==void 0){const e=t.nonWitnessUtxo.outputs.length-1;if(t.index>e)throw new Error(`validateInput: index(${t.index}) not in nonWitnessUtxo`);const n=t.nonWitnessUtxo.outputs[t.index];if(t.witnessUtxo&&(!H(t.witnessUtxo.script,n.script)||t.witnessUtxo.amount!==n.amount))throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo")}if(t.tapLeafScript)for(const[e,n]of t.tapLeafScript){if((e.version&254)!==n[n.length-1])throw new Error("validateInput: tapLeafScript version mimatch");if(n[n.length-1]&1)throw new Error("validateInput: tapLeafScript version has parity bit!")}if(t.nonWitnessUtxo&&t.index&&t.txid){if(t.nonWitnessUtxo.outputs.length-1<t.index)throw new Error("nonWitnessUtxo: incorect output index");const n=ye.fromRaw(St.encode(t.nonWitnessUtxo)),r=V.encode(t.txid);if(n.id!==r)throw new Error(`nonWitnessUtxo: wrong txid, exp=${r} got=${n.id}`)}return t}),nr=bt(tr(Pe),t=>{if(t.bip32Derivation)for(const[e,n]of t.bip32Derivation)ce(e,Z.ecdsa);return t}),Io=bt(tr(Jn),t=>{if((t.version||0)===0){if(!t.unsignedTx)throw new Error("PSBTv0: missing unsignedTx");if(t.unsignedTx.segwitFlag||t.unsignedTx.witnesses)throw new Error("PSBTv0: witness in unsingedTx");for(const n of t.unsignedTx.inputs)if(n.finalScriptSig&&n.finalScriptSig.length)throw new Error("PSBTv0: input scriptSig found in unsignedTx")}return t}),Xs=nt({magic:Qe(Ze(new Uint8Array([255])),"psbt"),global:Io,inputs:rt("global/unsignedTx/inputs/length",er),outputs:rt(null,nr)}),Js=nt({magic:Qe(Ze(new Uint8Array([255])),"psbt"),global:Io,inputs:rt("global/inputCount",er),outputs:rt("global/outputCount",nr)});nt({magic:Qe(Ze(new Uint8Array([255])),"psbt"),items:rt(null,Ee(rt(Fn,Cs([Ls(yt),W(Je)])),ue.dict()))});function dn(t,e,n){for(const r in n){if(r==="unknown"||!e[r])continue;const{allowInc:o}=Un(e[r]);if(!o.includes(t))throw new Error(`PSBTv${t}: field ${r} is not allowed`)}for(const r in e){const{reqInc:o}=Un(e[r]);if(o.includes(t)&&n[r]===void 0)throw new Error(`PSBTv${t}: missing required field ${r}`)}}function Ur(t,e,n){const r={};for(const o in n){const i=o;if(i!=="unknown"){if(!e[i])continue;const{allowInc:s,silentIgnore:c}=Un(e[i]);if(!s.includes(t)){if(c)continue;throw new Error(`Failed to serialize in PSBTv${t}: ${i} but versions allows inclusion=${s}`)}}r[i]=n[i]}return r}function To(t){const e=t&&t.global&&t.global.version||0;dn(e,Jn,t.global);for(const s of t.inputs)dn(e,Ke,s);for(const s of t.outputs)dn(e,Pe,s);const n=e?t.global.inputCount:t.global.unsignedTx.inputs.length;if(t.inputs.length<n)throw new Error("Not enough inputs");const r=t.inputs.slice(n);if(r.length>1||r.length&&Object.keys(r[0]).length)throw new Error(`Unexpected inputs left in tx=${r}`);const o=e?t.global.outputCount:t.global.unsignedTx.outputs.length;if(t.outputs.length<o)throw new Error("Not outputs inputs");const i=t.outputs.slice(o);if(i.length>1||i.length&&Object.keys(i[0]).length)throw new Error(`Unexpected outputs left in tx=${i}`);return t}function pn(t,e,n,r){const o={...n,...e};for(const i in t){const s=i,[c,a,f]=t[s],u=r&&!r.includes(i);if(e[i]===void 0&&i in e){if(u)throw new Error(`Cannot remove signed field=${i}`);delete o[i]}else if(a){const l=n&&n[i]?n[i]:[];let d=e[s];if(d){if(!Array.isArray(d))throw new Error(`keyMap(${i}): KV pairs should be [k, v][]`);d=d.map(h=>{if(h.length!==2)throw new Error(`keyMap(${i}): KV pairs should be [k, v][]`);return[typeof h[0]=="string"?a.decode(V.decode(h[0])):h[0],typeof h[1]=="string"?f.decode(V.decode(h[1])):h[1]]});const p={},y=(h,g,w)=>{if(p[h]===void 0){p[h]=[g,w];return}const b=V.encode(f.encode(p[h][1])),E=V.encode(f.encode(w));if(b!==E)throw new Error(`keyMap(${s}): same key=${h} oldVal=${b} newVal=${E}`)};for(const[h,g]of l){const w=V.encode(a.encode(h));y(w,h,g)}for(const[h,g]of d){const w=V.encode(a.encode(h));if(g===void 0){if(u)throw new Error(`Cannot remove signed field=${s}/${h}`);delete p[w]}else y(w,h,g)}o[s]=Object.values(p)}}else if(typeof o[i]=="string")o[i]=f.decode(V.decode(o[i]));else if(u&&i in e&&n&&n[i]!==void 0&&!H(f.encode(e[i]),f.encode(n[i])))throw new Error(`Cannot change signed field=${i}`)}for(const i in o)t[i]||delete o[i];return o}const Lr=bt(Xs,To),Rr=bt(Js,To),gn=nt({txid:W(32,!0),index:L}),tc={encode(t){if(!(t.length!==2||!D(t[0])||!Kt(t[0],Z.ecdsa)||t[1]!=="CHECKSIG"))return{type:"pk",pubkey:t[0]}},decode:t=>t.type==="pk"?[t.pubkey,"CHECKSIG"]:void 0},ec={encode(t){if(!(t.length!==5||t[0]!=="DUP"||t[1]!=="HASH160"||!D(t[2]))&&!(t[3]!=="EQUALVERIFY"||t[4]!=="CHECKSIG"))return{type:"pkh",hash:t[2]}},decode:t=>t.type==="pkh"?["DUP","HASH160",t.hash,"EQUALVERIFY","CHECKSIG"]:void 0},nc=(t,e=Xt)=>{if(!Kt(t,Z.ecdsa))throw new Error("P2PKH: invalid publicKey");const n=Xe(t);return{type:"pkh",script:X.encode({type:"pkh",hash:n}),address:en(e).encode({type:"pkh",hash:n})}},rc={encode(t){if(!(t.length!==3||t[0]!=="HASH160"||!D(t[1])||t[2]!=="EQUAL"))return{type:"sh",hash:t[1]}},decode:t=>t.type==="sh"?["HASH160",t.hash,"EQUAL"]:void 0},oc={encode(t){if(!(t.length!==2||t[0]!==0||!D(t[1]))&&t[1].length===32)return{type:"wsh",hash:t[1]}},decode:t=>t.type==="wsh"?[0,t.hash]:void 0},ic={encode(t){if(!(t.length!==2||t[0]!==0||!D(t[1]))&&t[1].length===20)return{type:"wpkh",hash:t[1]}},decode:t=>t.type==="wpkh"?[0,t.hash]:void 0},sc=(t,e=Xt)=>{if(!Kt(t,Z.ecdsa))throw new Error("P2WPKH: invalid publicKey");if(t.length===65)throw new Error("P2WPKH: uncompressed public key");const n=Xe(t);return{type:"wpkh",script:X.encode({type:"wpkh",hash:n}),address:en(e).encode({type:"wpkh",hash:n})}},cc={encode(t){const e=t.length-1;if(t[e]!=="CHECKMULTISIG")return;const n=t[0],r=t[e-1];if(typeof n!="number"||typeof r!="number")return;const o=t.slice(1,-2);if(r===o.length){for(const i of o)if(!D(i))return;return{type:"ms",m:n,pubkeys:o}}},decode:t=>t.type==="ms"?[t.m,...t.pubkeys,t.pubkeys.length,"CHECKMULTISIG"]:void 0},ac={encode(t){if(!(t.length!==2||t[0]!==1||!D(t[1])))return{type:"tr",pubkey:t[1]}},decode:t=>t.type==="tr"?[1,t.pubkey]:void 0};function fc(t){const e=Array.from(t);for(;e.length>=2;){e.sort((s,c)=>(c.weight||1)-(s.weight||1));const r=e.pop(),o=e.pop(),i=(o?.weight||1)+(r?.weight||1);e.push({weight:i,childs:[o?.childs||o,r?.childs||r]})}const n=e[0];return n?.childs||n}function lc(t,e=!1){const n=X.decode(t);if(!(n.type==="unknown"&&e)&&!["tr_ns","tr_ms"].includes(n.type))throw new Error(`P2TR: invalid leaf script=${n.type}`)}function Ln(t,e=!1){if(!t)throw new Error("taprootHashTree: empty tree");if(Array.isArray(t)&&t.length===1&&(t=t[0]),!Array.isArray(t)){const{leafVersion:s,script:c,tapInternalKey:a}=t;if(t.tapLeafScript||t.tapMerkleRoot&&!H(t.tapMerkleRoot,_))throw new Error("P2TR: tapRoot leafScript cannot have tree");if(a&&H(a,Bo))throw new Error("P2TR: tapRoot leafScript cannot have unspendble key");const f=typeof c=="string"?V.decode(c):c;if(!D(f))throw new Error(`checkScript: wrong script type=${f}`);return lc(f,e),{type:"leaf",tapInternalKey:a,version:s,script:f,hash:Te(f,s)}}if(t.length!==2&&(t=fc(t)),t.length!==2)throw new Error("hashTree: non binary tree!");const n=Ln(t[0],e),r=Ln(t[1],e);let[o,i]=[n.hash,r.hash];return $n(i,o)===-1&&([o,i]=[i,o]),{type:"branch",left:n,right:r,hash:ft.utils.taggedHash("TapBranch",o,i)}}function Rn(t,e=[]){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return{...t,path:e};if(t.type!=="branch")throw new Error(`taprootAddPath: wrong type=${t}`);return{...t,path:e,left:Rn(t.left,[t.right.hash,...e]),right:Rn(t.right,[t.left.hash,...e])}}function Nn(t){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return[t];if(t.type!=="branch")throw new Error(`taprootWalkTree: wrong type=${t}`);return[...Nn(t.left),...Nn(t.right)]}const Bo=wt(Fe.BASE.toRawBytes(!1));function uc(t,e,n=Xt,r=!1){if(!t&&!e)throw new Error("p2tr: should have pubKey or scriptTree (or both)");const o=typeof t=="string"?V.decode(t):t||Bo;if(!Kt(o,Z.schnorr))throw new Error("p2tr: non-schnorr pubkey");let i=e?Rn(Ln(e,r)):void 0;const s=i?i.hash:void 0,[c,a]=So(o,s||_);let f;i&&(f=Nn(i).map(d=>({...d,controlBlock:oe.encode({version:(d.version||Cn)+a,internalKey:d.tapInternalKey||o,merklePath:d.path})})));let u;f&&(u=f.map(d=>[oe.decode(d.controlBlock),Wt(d.script,new Uint8Array([d.version||Cn]))]));const l={type:"tr",script:X.encode({type:"tr",pubkey:c}),address:en(n).encode({type:"tr",pubkey:c}),tweakedPubkey:c,tapInternalKey:o};return f&&(l.leaves=f),u&&(l.tapLeafScript=u),s&&(l.tapMerkleRoot=s),l}const hc={encode(t){const e=t.length-1;if(t[e]!=="CHECKSIG")return;const n=[];for(let r=0;r<e;r++){const o=t[r];if(r&1){if(o!=="CHECKSIGVERIFY"||r===e-1)return;continue}if(!D(o))return;n.push(o)}return{type:"tr_ns",pubkeys:n}},decode:t=>{if(t.type!=="tr_ns")return;const e=[];for(let n=0;n<t.pubkeys.length-1;n++)e.push(t.pubkeys[n],"CHECKSIGVERIFY");return e.push(t.pubkeys[t.pubkeys.length-1],"CHECKSIG"),e}},dc={encode(t){const e=t.length-1;if(t[e]!=="NUMEQUAL"||t[1]!=="CHECKSIG")return;const n=[],r=Ks(t[e-1]);if(typeof r=="number"){for(let o=0;o<e-1;o++){const i=t[o];if(o&1){if(i!==(o===1?"CHECKSIG":"CHECKSIGADD"))throw new Error("OutScript.encode/tr_ms: wrong element");continue}if(!D(i))throw new Error("OutScript.encode/tr_ms: wrong key element");n.push(i)}return{type:"tr_ms",pubkeys:n,m:r}}},decode:t=>{if(t.type!=="tr_ms")return;const e=[t.pubkeys[0],"CHECKSIG"];for(let n=1;n<t.pubkeys.length;n++)e.push(t.pubkeys[n],"CHECKSIGADD");return e.push(t.m,"NUMEQUAL"),e}},pc={encode(t){return{type:"unknown",script:F.encode(t)}},decode:t=>t.type==="unknown"?F.decode(t.script):void 0},gc=[tc,ec,rc,oc,ic,cc,ac,hc,dc,pc],wc=Ee(F,ue.match(gc)),X=bt(wc,t=>{if(t.type==="pk"&&!Kt(t.pubkey,Z.ecdsa))throw new Error("OutScript/pk: wrong key");if((t.type==="pkh"||t.type==="sh"||t.type==="wpkh")&&(!D(t.hash)||t.hash.length!==20))throw new Error(`OutScript/${t.type}: wrong hash`);if(t.type==="wsh"&&(!D(t.hash)||t.hash.length!==32))throw new Error("OutScript/wsh: wrong hash");if(t.type==="tr"&&(!D(t.pubkey)||!Kt(t.pubkey,Z.schnorr)))throw new Error("OutScript/tr: wrong taproot public key");if((t.type==="ms"||t.type==="tr_ns"||t.type==="tr_ms")&&!Array.isArray(t.pubkeys))throw new Error("OutScript/multisig: wrong pubkeys array");if(t.type==="ms"){const e=t.pubkeys.length;for(const n of t.pubkeys)if(!Kt(n,Z.ecdsa))throw new Error("OutScript/multisig: wrong pubkey");if(t.m<=0||e>16||t.m>e)throw new Error("OutScript/multisig: invalid params")}if(t.type==="tr_ns"||t.type==="tr_ms"){for(const e of t.pubkeys)if(!Kt(e,Z.schnorr))throw new Error(`OutScript/${t.type}: wrong pubkey`)}if(t.type==="tr_ms"){const e=t.pubkeys.length;if(t.m<=0||e>999||t.m>e)throw new Error("OutScript/tr_ms: invalid params")}return t});function $o(t,e){if(e.length<2||e.length>40)throw new Error("Witness: invalid length");if(t>16)throw new Error("Witness: invalid version");if(t===0&&!(e.length===20||e.length===32))throw new Error("Witness: invalid length for version")}function wn(t,e,n=Xt){$o(t,e);const r=t===0?kn:go;return r.encode(n.bech32,[t].concat(r.toWords(e)))}function Nr(t,e){return Eo.encode(Wt(Uint8Array.from(e),t))}function en(t=Xt){return{encode(e){const{type:n}=e;if(n==="wpkh")return wn(0,e.hash,t);if(n==="wsh")return wn(0,e.hash,t);if(n==="tr")return wn(1,e.pubkey,t);if(n==="pkh")return Nr(e.hash,[t.pubKeyHash]);if(n==="sh")return Nr(e.hash,[t.scriptHash]);throw new Error(`Unknown address type=${n}`)},decode(e){if(e.length<14||e.length>74)throw new Error("Invalid address length");if(t.bech32&&e.toLowerCase().startsWith(t.bech32)){let r;try{if(r=kn.decode(e),r.words[0]!==0)throw new Error(`bech32: wrong version=${r.words[0]}`)}catch{if(r=go.decode(e),r.words[0]===0)throw new Error(`bech32m: wrong version=${r.words[0]}`)}if(r.prefix!==t.bech32)throw new Error(`wrong bech32 prefix=${r.prefix}`);const[o,...i]=r.words,s=kn.fromWords(i);if($o(o,s),o===0&&s.length===32)return{type:"wsh",hash:s};if(o===0&&s.length===20)return{type:"wpkh",hash:s};if(o===1&&s.length===32)return{type:"tr",pubkey:s};throw new Error("Unkown witness program")}const n=Eo.decode(e);if(n.length!==21)throw new Error("Invalid base58 address");if(n[0]===t.pubKeyHash)return{type:"pkh",hash:n.slice(1)};if(n[0]===t.scriptHash)return{type:"sh",hash:n.slice(1)};throw new Error(`Invalid address prefix=${n[0]}`)}}}var C;(function(t){t[t.DEFAULT=0]="DEFAULT",t[t.ALL=1]="ALL",t[t.NONE=2]="NONE",t[t.SINGLE=3]="SINGLE",t[t.ANYONECANPAY=128]="ANYONECANPAY"})(C||(C={}));Ee(L,ue.tsEnum(C));function Cr(t){const e=t&31;return{isAny:!!(t&C.ANYONECANPAY),isNone:e===C.NONE,isSingle:e===C.SINGLE}}function ke(t){if(t.txid===void 0||t.index===void 0)throw new Error("Transaction/input: txid and index required");return{txid:t.txid,index:t.index,sequence:we(t.sequence,vo),finalScriptSig:we(t.finalScriptSig,_)}}function _r(t){for(const e in t){const n=e;Zs.includes(n)||delete t[n]}}function ne(t){if(t.script===void 0||t.amount===void 0)throw new Error("Transaction/output: script and amount required");return{script:t.script,amount:t.amount}}const Cn=192,Te=(t,e=Cn)=>ft.utils.taggedHash("TapLeaf",new Uint8Array([e]),pt.encode(t));function Hr(t,e,n,r=_){return H(n,e)&&(t=Ds(t,r),e=ft.getPublicKey(t)),{privKey:t,pubKey:e}}const yc=t=>Object.prototype.toString.call(t)==="[object Object]"&&t.constructor===Object;function bc(t){if(!yc(t))throw new Error(`Wrong object type for transaction options: ${t}`);const e={...t,version:we(t.version,Vs),lockTime:we(t.lockTime,0),PSBTVersion:we(t.PSBTVersion,0)};if(![-1,0,1,2].includes(e.version))throw new Error(`Unknown version: ${e.version}`);if(typeof e.lockTime!="number")throw new Error("Transaction lock time should be number");if(L.encode(e.lockTime),e.PSBTVersion!==0&&e.PSBTVersion!==2)throw new Error(`Unknown PSBT version ${e.PSBTVersion}`);for(const n of["allowUnknowOutput","allowUnknowInput","disableScriptCheck","bip174jsCompat","allowLegacyWitnessUtxo","lowR"]){const r=e[n];if(r!==void 0&&typeof r!="boolean")throw new Error(`Transation options wrong type: ${n}=${r} (${typeof r})`)}return Object.freeze(e)}class ye{constructor(e={}){this.global={},this.inputs=[],this.outputs=[];const n=this.opts=bc(e);n.lockTime!==Yt&&(this.global.fallbackLocktime=n.lockTime),this.global.txVersion=n.version}static fromRaw(e,n={}){const r=St.decode(e),o=new ye({...n,version:r.version,lockTime:r.lockTime});for(const i of r.outputs)o.addOutput(i);if(o.outputs=r.outputs,o.inputs=r.inputs,r.witnesses)for(let i=0;i<r.witnesses.length;i++)o.inputs[i].finalScriptWitness=r.witnesses[i];return o}static fromPSBT(e,n={}){let r;try{r=Lr.decode(e)}catch(l){try{r=Rr.decode(e)}catch{throw l}}const o=r.global.version||0;if(o!==0&&o!==2)throw new Error(`Wrong PSBT version=${o}`);const i=r.global.unsignedTx,s=o===0?i?.version:r.global.txVersion,c=o===0?i?.lockTime:r.global.fallbackLocktime,a=new ye({...n,version:s,lockTime:c,PSBTVersion:o}),f=o===0?i?.inputs.length:r.global.inputCount;a.inputs=r.inputs.slice(0,f).map((l,d)=>({finalScriptSig:_,...r.global.unsignedTx?.inputs[d],...l}));const u=o===0?i?.outputs.length:r.global.outputCount;return a.outputs=r.outputs.slice(0,u).map((l,d)=>({...l,...r.global.unsignedTx?.outputs[d]})),a.global={...r.global,txVersion:s},c!==Yt&&(a.global.fallbackLocktime=c),a}toPSBT(e=this.opts.PSBTVersion){if(e!==0&&e!==2)throw new Error(`Wrong PSBT version=${e}`);const n=this.inputs.map(i=>Ur(e,Ke,i));for(const i of n)i.partialSig&&!i.partialSig.length&&delete i.partialSig,i.finalScriptSig&&!i.finalScriptSig.length&&delete i.finalScriptSig,i.finalScriptWitness&&!i.finalScriptWitness.length&&delete i.finalScriptWitness;const r=this.outputs.map(i=>Ur(e,Pe,i)),o={...this.global};return e===0?(o.unsignedTx=St.decode(this.unsignedTx),delete o.fallbackLocktime,delete o.txVersion):(o.version=e,o.txVersion=this.version,o.inputCount=this.inputs.length,o.outputCount=this.outputs.length,o.fallbackLocktime&&o.fallbackLocktime===Yt&&delete o.fallbackLocktime),this.opts.bip174jsCompat&&(n.length||n.push({}),r.length||r.push({})),(e===0?Lr:Rr).encode({global:o,inputs:n,outputs:r})}get lockTime(){let e=Yt,n=0,r=Yt,o=0;for(const i of this.inputs)i.requiredHeightLocktime&&(e=Math.max(e,i.requiredHeightLocktime),n++),i.requiredTimeLocktime&&(r=Math.max(r,i.requiredTimeLocktime),o++);return n&&n>=o?e:r!==Yt?r:this.global.fallbackLocktime||Yt}get version(){if(this.global.txVersion===void 0)throw new Error("No global.txVersion");return this.global.txVersion}inputStatus(e){this.checkInputIdx(e);const n=this.inputs[e];return n.finalScriptSig&&n.finalScriptSig.length||n.finalScriptWitness&&n.finalScriptWitness.length?"finalized":n.tapKeySig||n.tapScriptSig&&n.tapScriptSig.length||n.partialSig&&n.partialSig.length?"signed":"unsigned"}inputSighash(e){this.checkInputIdx(e);const n=this.inputType(this.inputs[e]).sighash,r=n===C.DEFAULT?C.ALL:n&3;return{sigInputs:n&C.ANYONECANPAY,sigOutputs:r}}signStatus(){let e=!0,n=!0,r=[],o=[];for(let i=0;i<this.inputs.length;i++){if(this.inputStatus(i)==="unsigned")continue;const{sigInputs:c,sigOutputs:a}=this.inputSighash(i);if(c===C.ANYONECANPAY?r.push(i):e=!1,a===C.ALL)n=!1;else if(a===C.SINGLE)o.push(i);else if(a!==C.NONE)throw new Error(`Wrong signature hash output type: ${a}`)}return{addInput:e,addOutput:n,inputs:r,outputs:o}}get isFinal(){for(let e=0;e<this.inputs.length;e++)if(this.inputStatus(e)!=="finalized")return!1;return!0}get hasWitnesses(){let e=!1;for(const n of this.inputs)n.finalScriptWitness&&n.finalScriptWitness.length&&(e=!0);return e}get weight(){if(!this.isFinal)throw new Error("Transaction is not finalized");let e=32;const n=this.outputs.map(ne);this.hasWitnesses&&(e+=2),e+=4*yt.encode(this.inputs.length).length,e+=4*yt.encode(this.outputs.length).length;for(const r of this.inputs)e+=160+4*pt.encode(r.finalScriptSig||_).length;for(const r of n)e+=32+4*pt.encode(r.script).length;if(this.hasWitnesses)for(const r of this.inputs)r.finalScriptWitness&&(e+=Xn.encode(r.finalScriptWitness).length);return e}get vsize(){return Math.ceil(this.weight/4)}toBytes(e=!1,n=!1){return St.encode({version:this.version,lockTime:this.lockTime,inputs:this.inputs.map(ke).map(r=>({...r,finalScriptSig:e&&r.finalScriptSig||_})),outputs:this.outputs.map(ne),witnesses:this.inputs.map(r=>r.finalScriptWitness||[]),segwitFlag:n&&this.hasWitnesses})}get unsignedTx(){return this.toBytes(!1,!1)}get hex(){return V.encode(this.toBytes(!0,this.hasWitnesses))}get hash(){if(!this.isFinal)throw new Error("Transaction is not finalized");return V.encode(Ht(this.toBytes(!0)))}get id(){if(!this.isFinal)throw new Error("Transaction is not finalized");return V.encode(Ht(this.toBytes(!0)).reverse())}checkInputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.inputs.length)throw new Error(`Wrong input index=${e}`)}getInput(e){return this.checkInputIdx(e),We(this.inputs[e])}get inputsLength(){return this.inputs.length}normalizeInput(e,n,r){let{nonWitnessUtxo:o,txid:i}=e;typeof o=="string"&&(o=V.decode(o)),D(o)&&(o=St.decode(o)),o===void 0&&(o=n?.nonWitnessUtxo),typeof i=="string"&&(i=V.decode(i)),i===void 0&&(i=n?.txid);let s={...n,...e,nonWitnessUtxo:o,txid:i};s.nonWitnessUtxo===void 0&&delete s.nonWitnessUtxo,s.sequence===void 0&&(s.sequence=vo),s.tapMerkleRoot===null&&delete s.tapMerkleRoot,s=pn(Ke,s,n,r),er.encode(s);let c;return s.nonWitnessUtxo&&s.index!==void 0?c=s.nonWitnessUtxo.outputs[s.index]:s.witnessUtxo&&(c=s.witnessUtxo),c&&!this.opts.disableScriptCheck&&$r(c&&c.script,s.redeemScript,s.witnessScript),s}addInput(e,n=!1){if(!n&&!this.signStatus().addInput)throw new Error("Tx has signed inputs, cannot add new one");return this.inputs.push(this.normalizeInput(e)),this.inputs.length-1}updateInput(e,n,r=!1){this.checkInputIdx(e);let o;if(!r){const i=this.signStatus();(!i.addInput||i.inputs.includes(e))&&(o=Qs)}this.inputs[e]=this.normalizeInput(n,this.inputs[e],o)}checkOutputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.outputs.length)throw new Error(`Wrong output index=${e}`)}getOutput(e){return this.checkOutputIdx(e),We(this.outputs[e])}get outputsLength(){return this.outputs.length}normalizeOutput(e,n,r){let{amount:o,script:i}=e;if(o===void 0&&(o=n?.amount),typeof o!="bigint")throw new Error("amount must be bigint sats");typeof i=="string"&&(i=V.decode(i)),i===void 0&&(i=n?.script);let s={...n,...e,amount:o,script:i};if(s.amount===void 0&&delete s.amount,s=pn(Pe,s,n,r),nr.encode(s),s.script&&!this.opts.allowUnknowOutput&&X.decode(s.script).type==="unknown")throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnkownScript=true, if you sure");return this.opts.disableScriptCheck||$r(s.script,s.redeemScript,s.witnessScript),s}addOutput(e,n=!1){if(!n&&!this.signStatus().addOutput)throw new Error("Tx has signed outputs, cannot add new one");return this.outputs.push(this.normalizeOutput(e)),this.outputs.length-1}updateOutput(e,n,r=!1){this.checkOutputIdx(e);let o;if(!r){const i=this.signStatus();(!i.addOutput||i.outputs.includes(e))&&(o=Fs)}this.outputs[e]=this.normalizeOutput(n,this.outputs[e],o)}addOutputAddress(e,n,r=Xt){return this.addOutput({script:X.encode(en(r).decode(e)),amount:n})}get fee(){let e=0n;for(const r of this.inputs){const o=this.prevOut(r);if(!o)throw new Error("Empty input amount");e+=o.amount}const n=this.outputs.map(ne);for(const r of n)e-=r.amount;return e}preimageLegacy(e,n,r){const{isAny:o,isNone:i,isSingle:s}=Cr(r);if(e<0||!Number.isSafeInteger(e))throw new Error(`Invalid input idx=${e}`);if(s&&e>=this.outputs.length||e>=this.inputs.length)return Bs.encode(1n);n=F.encode(F.decode(n).filter(u=>u!=="CODESEPARATOR"));let c=this.inputs.map(ke).map((u,l)=>({...u,finalScriptSig:l===e?n:_}));o?c=[c[e]]:(i||s)&&(c=c.map((u,l)=>({...u,sequence:l===e?u.sequence:0})));let a=this.outputs.map(ne);i?a=[]:s&&(a=a.slice(0,e).fill(qs).concat([a[e]]));const f=St.encode({lockTime:this.lockTime,version:this.version,segwitFlag:!1,inputs:c,outputs:a});return Ht(f,ge.encode(r))}preimageWitnessV0(e,n,r,o){const{isAny:i,isNone:s,isSingle:c}=Cr(r);let a=Ae,f=Ae,u=Ae;const l=this.inputs.map(ke),d=this.outputs.map(ne);i||(a=Ht(...l.map(gn.encode))),!i&&!c&&!s&&(f=Ht(...l.map(y=>L.encode(y.sequence)))),!c&&!s?u=Ht(...d.map(re.encode)):c&&e<d.length&&(u=Ht(re.encode(d[e])));const p=l[e];return Ht(ge.encode(this.version),a,f,W(32,!0).encode(p.txid),L.encode(p.index),pt.encode(n),Ie.encode(o),L.encode(p.sequence),u,L.encode(this.lockTime),L.encode(r))}preimageWitnessV1(e,n,r,o,i=-1,s,c=192,a){if(!Array.isArray(o)||this.inputs.length!==o.length)throw new Error(`Invalid amounts array=${o}`);if(!Array.isArray(n)||this.inputs.length!==n.length)throw new Error(`Invalid prevOutScript array=${n}`);const f=[qt.encode(0),qt.encode(r),ge.encode(this.version),L.encode(this.lockTime)],u=r===C.DEFAULT?C.ALL:r&3,l=r&C.ANYONECANPAY,d=this.inputs.map(ke),p=this.outputs.map(ne);l!==C.ANYONECANPAY&&f.push(...[d.map(gn.encode),o.map(Ie.encode),n.map(pt.encode),d.map(h=>L.encode(h.sequence))].map(h=>wt(Wt(...h)))),u===C.ALL&&f.push(wt(Wt(...p.map(re.encode))));const y=(a?1:0)|(s?2:0);if(f.push(new Uint8Array([y])),l===C.ANYONECANPAY){const h=d[e];f.push(gn.encode(h),Ie.encode(o[e]),pt.encode(n[e]),L.encode(h.sequence))}else f.push(L.encode(e));return y&1&&f.push(wt(pt.encode(a||_))),u===C.SINGLE&&f.push(e<p.length?wt(re.encode(p[e])):Ae),s&&f.push(Te(s,c),qt.encode(0),ge.encode(i)),ft.utils.taggedHash("TapSighash",...f)}prevOut(e){if(e.nonWitnessUtxo){if(e.index===void 0)throw new Error("Uknown input index");return e.nonWitnessUtxo.outputs[e.index]}else{if(e.witnessUtxo)return e.witnessUtxo;throw new Error("Cannot find previous output info.")}}inputType(e){let n="legacy",r=C.ALL;const o=this.prevOut(e),i=X.decode(o.script);let s=i.type,c=i;const a=[i];if(i.type==="tr")return r=C.DEFAULT,{txType:"taproot",type:"tr",last:i,lastScript:o.script,defaultSighash:r,sighash:e.sighashType||r};{if((i.type==="wpkh"||i.type==="wsh")&&(n="segwit"),i.type==="sh"){if(!e.redeemScript)throw new Error("inputType: sh without redeemScript");let d=X.decode(e.redeemScript);(d.type==="wpkh"||d.type==="wsh")&&(n="segwit"),a.push(d),c=d,s+=`-${d.type}`}if(c.type==="wsh"){if(!e.witnessScript)throw new Error("inputType: wsh without witnessScript");let d=X.decode(e.witnessScript);d.type==="wsh"&&(n="segwit"),a.push(d),c=d,s+=`-${d.type}`}const f=a[a.length-1];if(f.type==="sh"||f.type==="wsh")throw new Error("inputType: sh/wsh cannot be terminal type");const u=X.encode(f),l={type:s,txType:n,last:f,lastScript:u,defaultSighash:r,sighash:e.sighashType||r};if(n==="legacy"&&!this.opts.allowLegacyWitnessUtxo&&!e.nonWitnessUtxo)throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");return l}}signIdx(e,n,r,o){this.checkInputIdx(n);const i=this.inputs[n],s=this.inputType(i);if(!D(e)){if(!i.bip32Derivation||!i.bip32Derivation.length)throw new Error("bip32Derivation: empty");const l=i.bip32Derivation.filter(p=>p[1].fingerprint==e.fingerprint).map(([p,{path:y}])=>{let h=e;for(const g of y)h=h.deriveChild(g);if(!H(h.publicKey,p))throw new Error("bip32Derivation: wrong pubKey");if(!h.privateKey)throw new Error("bip32Derivation: no privateKey");return h});if(!l.length)throw new Error(`bip32Derivation: no items with fingerprint=${e.fingerprint}`);let d=!1;for(const p of l)this.signIdx(p.privateKey,n)&&(d=!0);return d}r||(r=[s.defaultSighash]);const c=s.sighash;if(!r.includes(c))throw new Error(`Input with not allowed sigHash=${c}. Allowed: ${r.join(", ")}`);const{sigInputs:a,sigOutputs:f}=this.inputSighash(n);if(f===C.SINGLE&&n>=this.outputs.length)throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${n}`);const u=this.prevOut(i);if(s.txType==="taproot"){if(i.tapBip32Derivation)throw new Error("tapBip32Derivation unsupported");const l=this.inputs.map(this.prevOut),d=l.map(w=>w.script),p=l.map(w=>w.amount);let y=!1,h=ft.getPublicKey(e),g=i.tapMerkleRoot||_;if(i.tapInternalKey){const{pubKey:w,privKey:b}=Hr(e,h,i.tapInternalKey,g),[E,A]=So(i.tapInternalKey,g);if(H(E,w)){const v=this.preimageWitnessV1(n,d,c,p),x=Wt(ft.sign(v,b,o),c!==C.DEFAULT?new Uint8Array([c]):_);this.updateInput(n,{tapKeySig:x},!0),y=!0}}if(i.tapLeafScript){i.tapScriptSig=i.tapScriptSig||[];for(const[w,b]of i.tapLeafScript){const E=b.subarray(0,-1),A=F.decode(E),v=b[b.length-1],x=Te(E,v),{pubKey:k,privKey:I}=Hr(e,h,w.internalKey,_);if(A.findIndex(Q=>D(Q)&&H(Q,k))===-1)continue;const R=this.preimageWitnessV1(n,d,c,p,void 0,E,v),B=Wt(ft.sign(R,I,o),c!==C.DEFAULT?new Uint8Array([c]):_);this.updateInput(n,{tapScriptSig:[[{pubKey:k,leafHash:x},B]]},!0),y=!0}}if(!y)throw new Error("No taproot scripts signed");return!0}else{const l=mo(e);let d=!1;const p=Xe(l);for(const g of F.decode(s.lastScript))D(g)&&(H(g,l)||H(g,p))&&(d=!0);if(!d)throw new Error(`Input script doesn't have pubKey: ${s.lastScript}`);let y;if(s.txType==="legacy")y=this.preimageLegacy(n,s.lastScript,c);else if(s.txType==="segwit"){let g=s.lastScript;s.last.type==="wpkh"&&(g=X.encode({type:"pkh",hash:s.last.hash})),y=this.preimageWitnessV0(n,g,c,u.amount)}else throw new Error(`Transaction/sign: unknown tx type: ${s.txType}`);const h=Hs(y,e,this.opts.lowR);this.updateInput(n,{partialSig:[[l,Wt(h,new Uint8Array([c]))]]},!0)}return!0}sign(e,n,r){let o=0;for(let i=0;i<this.inputs.length;i++)try{this.signIdx(e,i,n,r)&&o++}catch{}if(!o)throw new Error("No inputs signed");return o}finalizeIdx(e){if(this.checkInputIdx(e),this.fee<0n)throw new Error("Outputs spends more than inputs amount");const n=this.inputs[e],r=this.inputType(n);if(r.txType==="taproot"){if(n.tapKeySig)n.finalScriptWitness=[n.tapKeySig];else if(n.tapLeafScript&&n.tapScriptSig){const a=n.tapLeafScript.sort((f,u)=>oe.encode(f[0]).length-oe.encode(u[0]).length);for(const[f,u]of a){const l=u.slice(0,-1),d=u[u.length-1],p=X.decode(l),y=Te(l,d),h=n.tapScriptSig.filter(w=>H(w[0].leafHash,y));let g=[];if(p.type==="tr_ms"){const w=p.m,b=p.pubkeys;let E=0;for(const A of b){const v=h.findIndex(x=>H(x[0].pubKey,A));if(E===w||v===-1){g.push(_);continue}g.push(h[v][1]),E++}if(E!==w)continue}else if(p.type==="tr_ns"){for(const w of p.pubkeys){const b=h.findIndex(E=>H(E[0].pubKey,w));b!==-1&&g.push(h[b][1])}if(g.length!==p.pubkeys.length)continue}else if(p.type==="unknown"&&this.opts.allowUnknowInput){const w=F.decode(l);if(g=h.map(([{pubKey:b},E])=>{const A=w.findIndex(v=>D(v)&&H(v,b));if(A===-1)throw new Error("finalize/taproot: cannot find position of pubkey in script");return{signature:E,pos:A}}).sort((b,E)=>b.pos-E.pos).map(b=>b.signature),!g.length)continue}else throw new Error("Finalize: Unknown tapLeafScript");n.finalScriptWitness=g.reverse().concat([l,oe.encode(f)]);break}if(!n.finalScriptWitness)throw new Error("finalize/taproot: empty witness")}else throw new Error("finalize/taproot: unknown input");n.finalScriptSig=_,_r(n);return}if(!n.partialSig||!n.partialSig.length)throw new Error("Not enough partial sign");let o=_,i=[];if(r.last.type==="ms"){const a=r.last.m,f=r.last.pubkeys;let u=[];for(const l of f){const d=n.partialSig.find(p=>H(l,p[0]));d&&u.push(d[1])}if(u=u.slice(0,a),u.length!==a)throw new Error(`Multisig: wrong signatures count, m=${a} n=${f.length} signatures=${u.length}`);o=F.encode([0,...u])}else if(r.last.type==="pk")o=F.encode([n.partialSig[0][1]]);else if(r.last.type==="pkh")o=F.encode([n.partialSig[0][1],n.partialSig[0][0]]);else if(r.last.type==="wpkh")o=_,i=[n.partialSig[0][1],n.partialSig[0][0]];else if(r.last.type==="unknown"&&!this.opts.allowUnknowInput)throw new Error("Unknown inputs not allowed");let s,c;if(r.type.includes("wsh-")&&(o.length&&r.lastScript.length&&(i=F.decode(o).map(a=>{if(a===0)return _;if(D(a))return a;throw new Error(`Wrong witness op=${a}`)})),i=i.concat(r.lastScript)),r.txType==="segwit"&&(c=i),r.type.startsWith("sh-wsh-")?s=F.encode([F.encode([0,wt(r.lastScript)])]):r.type.startsWith("sh-")?s=F.encode([...F.decode(o),r.lastScript]):r.type.startsWith("wsh-")||r.txType!=="segwit"&&(s=o),!s&&!c)throw new Error("Unknown error finalizing input");s&&(n.finalScriptSig=s),c&&(n.finalScriptWitness=c),_r(n)}finalize(){for(let e=0;e<this.inputs.length;e++)this.finalizeIdx(e)}extract(){if(!this.isFinal)throw new Error("Transaction has unfinalized inputs");if(!this.outputs.length)throw new Error("Transaction has no outputs");if(this.fee<0n)throw new Error("Outputs spends more than inputs amount");return this.toBytes(!0,!0)}combine(e){for(const o of["PSBTVersion","version","lockTime"])if(this.opts[o]!==e.opts[o])throw new Error(`Transaction/combine: different ${o} this=${this.opts[o]} other=${e.opts[o]}`);for(const o of["inputs","outputs"])if(this[o].length!==e[o].length)throw new Error(`Transaction/combine: different ${o} length this=${this[o].length} other=${e[o].length}`);const n=this.global.unsignedTx?St.encode(this.global.unsignedTx):_,r=e.global.unsignedTx?St.encode(e.global.unsignedTx):_;if(!H(n,r))throw new Error("Transaction/combine: different unsigned tx");this.global=pn(Jn,this.global,e.global);for(let o=0;o<this.inputs.length;o++)this.updateInput(o,e.inputs[o],!0);for(let o=0;o<this.outputs.length;o++)this.updateOutput(o,e.outputs[o],!0);return this}clone(){return ye.fromPSBT(this.toPSBT(2),this.opts)}}function Cc(t,e,n=Xt){if(t==="tr")return uc(ft.getPublicKey(e),void 0,n).address;const r=mo(e);if(t==="pkh")return nc(r,n).address;if(t==="wpkh")return sc(r,n).address;throw new Error(`getAddress: unknown type=${t}`)}export{ts as H,Sc as N,Nc as T,Xt as a,ln as b,Uc as c,Lc as d,vc as e,Ec as f,Cc as g,xc as h,Rc as r,wt as s,Gn as t,$c as u,Yn as w};
