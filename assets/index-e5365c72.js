import{e as J,a0 as Ve,f as V,g as at,j as Ie,u as gn,k as Zt,m as wn,n as yn,o as B,ar as pr,bD as ii,i as $t,M as oi,O as si,l as gr,aj as ci,R as ai,K as fi,bE as li,Q as ui,ak as hi,bF as di}from"./index-2af5e715.js";const pi=J("divider",`
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`,[Ve("vertical",`
 margin-top: 24px;
 margin-bottom: 24px;
 `,[Ve("no-title",`
 display: flex;
 align-items: center;
 `)]),V("title",`
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `),at("title-position-left",[V("line",[at("left",{width:"28px"})])]),at("title-position-right",[V("line",[at("right",{width:"28px"})])]),at("dashed",[V("line",`
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]),at("vertical",`
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `),V("line",`
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `),Ve("dashed",[V("line",{backgroundColor:"var(--n-color)"})]),at("dashed",[V("line",{borderColor:"var(--n-color)"})]),at("vertical",{backgroundColor:"var(--n-color)"})]),gi=Object.assign(Object.assign({},Zt.props),{titlePlacement:{type:String,default:"center"},dashed:Boolean,vertical:Boolean}),As=Ie({name:"Divider",props:gi,setup(t){const{mergedClsPrefixRef:e,inlineThemeDisabled:n}=gn(t),r=Zt("Divider","-divider",pi,ii,t,e),i=wn(()=>{const{common:{cubicBezierEaseInOut:s},self:{color:c,textColor:a,fontWeight:f}}=r.value;return{"--n-bezier":s,"--n-color":c,"--n-text-color":a,"--n-font-weight":f}}),o=n?yn("divider",void 0,i,t):void 0;return{mergedClsPrefix:e,cssVars:n?void 0:i,themeClass:o?.themeClass,onRender:o?.onRender}},render(){var t;const{$slots:e,titlePlacement:n,vertical:r,dashed:i,cssVars:o,mergedClsPrefix:s}=this;return(t=this.onRender)===null||t===void 0||t.call(this),B("div",{role:"separator",class:[`${s}-divider`,this.themeClass,{[`${s}-divider--vertical`]:r,[`${s}-divider--no-title`]:!e.default,[`${s}-divider--dashed`]:i,[`${s}-divider--title-position-${n}`]:e.default&&n}],style:o},r?null:B("div",{class:`${s}-divider__line ${s}-divider__line--left`}),!r&&e.default?B(pr,null,B("div",{class:`${s}-divider__title`},this.$slots),B("div",{class:`${s}-divider__line ${s}-divider__line--right`})):null)}}),wi=$t([J("list",`
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `,[at("show-divider",[J("list-item",[$t("&:not(:last-child)",[V("divider",`
 background-color: var(--n-merged-border-color);
 `)])])]),at("clickable",[J("list-item",`
 cursor: pointer;
 `)]),at("bordered",`
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `),at("hoverable",[J("list-item",`
 border-radius: var(--n-border-radius);
 `,[$t("&:hover",`
 background-color: var(--n-merged-color-hover);
 `,[V("divider",`
 background-color: transparent;
 `)])])]),at("bordered, hoverable",[J("list-item",`
 padding: 12px 20px;
 `),V("header, footer",`
 padding: 12px 20px;
 `)]),V("header, footer",`
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `,[$t("&:not(:last-child)",`
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]),J("list-item",`
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `,[V("prefix",`
 margin-right: 20px;
 flex: 0;
 `),V("suffix",`
 margin-left: 20px;
 flex: 0;
 `),V("main",`
 flex: 1;
 `),V("divider",`
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]),oi(J("list",`
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)),si(J("list",`
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]),yi=Object.assign(Object.assign({},Zt.props),{size:{type:String,default:"medium"},bordered:Boolean,clickable:Boolean,hoverable:Boolean,showDivider:{type:Boolean,default:!0}}),wr=fi("n-list"),ks=Ie({name:"List",props:yi,setup(t){const{mergedClsPrefixRef:e,inlineThemeDisabled:n,mergedRtlRef:r}=gn(t),i=gr("List",r,e),o=Zt("List","-list",wi,li,t,e);ci(wr,{showDividerRef:ai(t,"showDivider"),mergedClsPrefixRef:e});const s=wn(()=>{const{common:{cubicBezierEaseInOut:a},self:{fontSize:f,textColor:l,color:u,colorModal:d,colorPopover:p,borderColor:y,borderColorModal:h,borderColorPopover:g,borderRadius:w,colorHover:m,colorHoverModal:E,colorHoverPopover:A}}=o.value;return{"--n-font-size":f,"--n-bezier":a,"--n-text-color":l,"--n-color":u,"--n-border-radius":w,"--n-border-color":y,"--n-border-color-modal":h,"--n-border-color-popover":g,"--n-color-modal":d,"--n-color-popover":p,"--n-color-hover":m,"--n-color-hover-modal":E,"--n-color-hover-popover":A}}),c=n?yn("list",void 0,s,t):void 0;return{mergedClsPrefix:e,rtlEnabled:i,cssVars:n?void 0:s,themeClass:c?.themeClass,onRender:c?.onRender}},render(){var t;const{$slots:e,mergedClsPrefix:n,onRender:r}=this;return r?.(),B("ul",{class:[`${n}-list`,this.rtlEnabled&&`${n}-list--rtl`,this.bordered&&`${n}-list--bordered`,this.showDivider&&`${n}-list--show-divider`,this.hoverable&&`${n}-list--hoverable`,this.clickable&&`${n}-list--clickable`,this.themeClass],style:this.cssVars},e.header?B("div",{class:`${n}-list__header`},e.header()):null,(t=e.default)===null||t===void 0?void 0:t.call(e),e.footer?B("div",{class:`${n}-list__footer`},e.footer()):null)}}),Is=Ie({name:"ListItem",setup(){const t=ui(wr,null);return t||hi("list-item","`n-list-item` must be placed in `n-list`."),{showDivider:t.showDividerRef,mergedClsPrefix:t.mergedClsPrefixRef}},render(){const{$slots:t,mergedClsPrefix:e}=this;return B("li",{class:`${e}-list-item`},t.prefix?B("div",{class:`${e}-list-item__prefix`},t.prefix()):null,t.default?B("div",{class:`${e}-list-item__main`},t):null,t.suffix?B("div",{class:`${e}-list-item__suffix`},t.suffix()):null,this.showDivider&&B("div",{class:`${e}-list-item__divider`}))}}),bi=J("thing",`
 display: flex;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
`,[J("thing-avatar",`
 margin-right: 12px;
 margin-top: 2px;
 `),J("thing-avatar-header-wrapper",`
 display: flex;
 flex-wrap: nowrap;
 `,[J("thing-header-wrapper",`
 flex: 1;
 `)]),J("thing-main",`
 flex-grow: 1;
 `,[J("thing-header",`
 display: flex;
 margin-bottom: 4px;
 justify-content: space-between;
 align-items: center;
 `,[V("title",`
 font-size: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-title-text-color);
 `)]),V("description",[$t("&:not(:last-child)",`
 margin-bottom: 4px;
 `)]),V("content",[$t("&:not(:first-child)",`
 margin-top: 12px;
 `)]),V("footer",[$t("&:not(:first-child)",`
 margin-top: 12px;
 `)]),V("action",[$t("&:not(:first-child)",`
 margin-top: 12px;
 `)])])]),mi=Object.assign(Object.assign({},Zt.props),{title:String,titleExtra:String,description:String,descriptionStyle:[String,Object],content:String,contentStyle:[String,Object],contentIndented:Boolean}),Ts=Ie({name:"Thing",props:mi,setup(t,{slots:e}){const{mergedClsPrefixRef:n,inlineThemeDisabled:r,mergedRtlRef:i}=gn(t),o=Zt("Thing","-thing",bi,di,t,n),s=gr("Thing",i,n),c=wn(()=>{const{self:{titleTextColor:f,textColor:l,titleFontWeight:u,fontSize:d},common:{cubicBezierEaseInOut:p}}=o.value;return{"--n-bezier":p,"--n-font-size":d,"--n-text-color":l,"--n-title-font-weight":u,"--n-title-text-color":f}}),a=r?yn("thing",void 0,c,t):void 0;return()=>{var f;const{value:l}=n,u=s?s.value:!1;return(f=a?.onRender)===null||f===void 0||f.call(a),B("div",{class:[`${l}-thing`,a?.themeClass,u&&`${l}-thing--rtl`],style:r?void 0:c.value},e.avatar&&t.contentIndented?B("div",{class:`${l}-thing-avatar`},e.avatar()):null,B("div",{class:`${l}-thing-main`},!t.contentIndented&&(e.header||t.title||e["header-extra"]||t.titleExtra||e.avatar)?B("div",{class:`${l}-thing-avatar-header-wrapper`},e.avatar?B("div",{class:`${l}-thing-avatar`},e.avatar()):null,e.header||t.title||e["header-extra"]||t.titleExtra?B("div",{class:`${l}-thing-header-wrapper`},B("div",{class:`${l}-thing-header`},e.header||t.title?B("div",{class:`${l}-thing-header__title`},e.header?e.header():t.title):null,e["header-extra"]||t.titleExtra?B("div",{class:`${l}-thing-header__extra`},e["header-extra"]?e["header-extra"]():t.titleExtra):null),e.description||t.description?B("div",{class:`${l}-thing-main__description`,style:t.descriptionStyle},e.description?e.description():t.description):null):null):B(pr,null,e.header||t.title||e["header-extra"]||t.titleExtra?B("div",{class:`${l}-thing-header`},e.header||t.title?B("div",{class:`${l}-thing-header__title`},e.header?e.header():t.title):null,e["header-extra"]||t.titleExtra?B("div",{class:`${l}-thing-header__extra`},e["header-extra"]?e["header-extra"]():t.titleExtra):null):null,e.description||t.description?B("div",{class:`${l}-thing-main__description`,style:t.descriptionStyle},e.description?e.description():t.description):null),e.default||t.content?B("div",{class:`${l}-thing-main__content`,style:t.contentStyle},e.default?e.default():t.content):null,e.footer?B("div",{class:`${l}-thing-main__footer`},e.footer()):null,e.action?B("div",{class:`${l}-thing-main__action`},e.action()):null))}}});function Wn(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function yr(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Ei(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Wn(t.outputLen),Wn(t.blockLen)}function pe(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Si(t,e){yr(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ze=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const br=t=>t instanceof Uint8Array,Fe=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),bt=(t,e)=>t<<32-e|t>>>e,xi=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!xi)throw new Error("Non little-endian hardware is not supported");function vi(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function bn(t){if(typeof t=="string"&&(t=vi(t)),!br(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Ai(...t){const e=new Uint8Array(t.reduce((r,i)=>r+i.length,0));let n=0;return t.forEach(r=>{if(!br(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}class mr{clone(){return this._cloneInto()}}function Er(t){const e=r=>t().update(bn(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Sr(t=32){if(ze&&typeof ze.getRandomValues=="function")return ze.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function ki(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const i=BigInt(32),o=BigInt(4294967295),s=Number(n>>i&o),c=Number(n&o),a=r?4:0,f=r?0:4;t.setUint32(e+a,s,r),t.setUint32(e+f,c,r)}class xr extends mr{constructor(e,n,r,i){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=i,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Fe(this.buffer)}update(e){pe(this);const{view:n,buffer:r,blockLen:i}=this;e=bn(e);const o=e.length;for(let s=0;s<o;){const c=Math.min(i-this.pos,o-s);if(c===i){const a=Fe(e);for(;i<=o-s;s+=i)this.process(a,s);continue}r.set(e.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===i&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){pe(this),Si(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:i,isLE:o}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>i-s&&(this.process(r,0),s=0);for(let u=s;u<i;u++)n[u]=0;ki(r,i-8,BigInt(this.length*8),o),this.process(r,0);const c=Fe(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,l[u],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:i,finished:o,destroyed:s,pos:c}=this;return e.length=i,e.pos=c,e.finished=o,e.destroyed=s,i%n&&e.buffer.set(r),e}}const Ii=(t,e,n)=>t&e^~t&n,Ti=(t,e,n)=>t&e^t&n^e&n,Bi=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),It=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Tt=new Uint32Array(64);class Ui extends xr{constructor(){super(64,32,8,!1),this.A=It[0]|0,this.B=It[1]|0,this.C=It[2]|0,this.D=It[3]|0,this.E=It[4]|0,this.F=It[5]|0,this.G=It[6]|0,this.H=It[7]|0}get(){const{A:e,B:n,C:r,D:i,E:o,F:s,G:c,H:a}=this;return[e,n,r,i,o,s,c,a]}set(e,n,r,i,o,s,c,a){this.A=e|0,this.B=n|0,this.C=r|0,this.D=i|0,this.E=o|0,this.F=s|0,this.G=c|0,this.H=a|0}process(e,n){for(let u=0;u<16;u++,n+=4)Tt[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const d=Tt[u-15],p=Tt[u-2],y=bt(d,7)^bt(d,18)^d>>>3,h=bt(p,17)^bt(p,19)^p>>>10;Tt[u]=h+Tt[u-7]+y+Tt[u-16]|0}let{A:r,B:i,C:o,D:s,E:c,F:a,G:f,H:l}=this;for(let u=0;u<64;u++){const d=bt(c,6)^bt(c,11)^bt(c,25),p=l+d+Ii(c,a,f)+Bi[u]+Tt[u]|0,h=(bt(r,2)^bt(r,13)^bt(r,22))+Ti(r,i,o)|0;l=f,f=a,a=c,c=s+p|0,s=o,o=i,i=r,r=p+h|0}r=r+this.A|0,i=i+this.B|0,o=o+this.C|0,s=s+this.D|0,c=c+this.E|0,a=a+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(r,i,o,s,c,a,f,l)}roundClean(){Tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const et=Er(()=>new Ui);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const vr=BigInt(0),Te=BigInt(1),$i=BigInt(2),Be=t=>t instanceof Uint8Array,Ni=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Gt(t){if(!Be(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Ni[t[n]];return e}function Ar(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function mn(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function Ot(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const i=r*2,o=t.slice(i,i+2),s=Number.parseInt(o,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");n[r]=s}return n}function nt(t){return mn(Gt(t))}function En(t){if(!Be(t))throw new Error("Uint8Array expected");return mn(Gt(Uint8Array.from(t).reverse()))}function Ct(t,e){return Ot(t.toString(16).padStart(e*2,"0"))}function Sn(t,e){return Ct(t,e).reverse()}function Li(t){return Ot(Ar(t))}function Z(t,e,n){let r;if(typeof e=="string")try{r=Ot(e)}catch(o){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`)}else if(Be(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const i=r.length;if(typeof n=="number"&&i!==n)throw new Error(`${t} expected ${n} bytes, got ${i}`);return r}function Pt(...t){const e=new Uint8Array(t.reduce((r,i)=>r+i.length,0));let n=0;return t.forEach(r=>{if(!Be(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function Ci(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Ri(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function _i(t){let e;for(e=0;t>vr;t>>=Te,e+=1);return e}function Hi(t,e){return t>>BigInt(e)&Te}const Di=(t,e,n)=>t|(n?Te:vr)<<BigInt(e),xn=t=>($i<<BigInt(t-1))-Te,qe=t=>new Uint8Array(t),Pn=t=>Uint8Array.from(t);function kr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=qe(t),i=qe(t),o=0;const s=()=>{r.fill(1),i.fill(0),o=0},c=(...u)=>n(i,r,...u),a=(u=qe())=>{i=c(Pn([0]),u),r=c(),u.length!==0&&(i=c(Pn([1]),u),r=c())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const d=[];for(;u<e;){r=c();const p=r.slice();d.push(p),u+=r.length}return Pt(...d)};return(u,d)=>{s(),a(u);let p;for(;!(p=d(f()));)a();return s(),p}}const Wi={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function ie(t,e,n={}){const r=(i,o,s)=>{const c=Wi[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const a=t[i];if(!(s&&a===void 0)&&!c(a,t))throw new Error(`Invalid param ${String(i)}=${a} (${typeof a}), expected ${o}`)};for(const[i,o]of Object.entries(e))r(i,o,!1);for(const[i,o]of Object.entries(n))r(i,o,!0);return t}const Pi=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Hi,bitLen:_i,bitMask:xn,bitSet:Di,bytesToHex:Gt,bytesToNumberBE:nt,bytesToNumberLE:En,concatBytes:Pt,createHmacDrbg:kr,ensureBytes:Z,equalBytes:Ci,hexToBytes:Ot,hexToNumber:mn,numberToBytesBE:Ct,numberToBytesLE:Sn,numberToHexUnpadded:Ar,numberToVarBytesBE:Li,utf8ToBytes:Ri,validateObject:ie},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const M=BigInt(0),K=BigInt(1),Dt=BigInt(2),Ki=BigInt(3),Qe=BigInt(4),Kn=BigInt(5),Vn=BigInt(8);BigInt(9);BigInt(16);function G(t,e){const n=t%e;return n>=M?n:e+n}function Vi(t,e,n){if(n<=M||e<M)throw new Error("Expected power/modulo > 0");if(n===K)return M;let r=K;for(;e>M;)e&K&&(r=r*t%n),t=t*t%n,e>>=K;return r}function ut(t,e,n){let r=t;for(;e-- >M;)r*=r,r%=n;return r}function Xe(t,e){if(t===M||e<=M)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=G(t,e),r=e,i=M,o=K;for(;n!==M;){const c=r/n,a=r%n,f=i-o*c;r=n,n=a,i=o,o=f}if(r!==K)throw new Error("invert: does not exist");return G(i,e)}function zi(t){const e=(t-K)/Dt;let n,r,i;for(n=t-K,r=0;n%Dt===M;n/=Dt,r++);for(i=Dt;i<t&&Vi(i,e,t)!==t-K;i++);if(r===1){const s=(t+K)/Qe;return function(a,f){const l=a.pow(f,s);if(!a.eql(a.sqr(l),f))throw new Error("Cannot find square root");return l}}const o=(n+K)/Dt;return function(c,a){if(c.pow(a,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=r,l=c.pow(c.mul(c.ONE,i),n),u=c.pow(a,o),d=c.pow(a,n);for(;!c.eql(d,c.ONE);){if(c.eql(d,c.ZERO))return c.ZERO;let p=1;for(let h=c.sqr(d);p<f&&!c.eql(h,c.ONE);p++)h=c.sqr(h);const y=c.pow(l,K<<BigInt(f-p-1));l=c.sqr(y),u=c.mul(u,y),d=c.mul(d,l),f=p}return u}}function Fi(t){if(t%Qe===Ki){const e=(t+K)/Qe;return function(r,i){const o=r.pow(i,e);if(!r.eql(r.sqr(o),i))throw new Error("Cannot find square root");return o}}if(t%Vn===Kn){const e=(t-Kn)/Vn;return function(r,i){const o=r.mul(i,Dt),s=r.pow(o,e),c=r.mul(i,s),a=r.mul(r.mul(c,Dt),s),f=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(f),i))throw new Error("Cannot find square root");return f}}return zi(t)}const qi=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Mi(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=qi.reduce((r,i)=>(r[i]="function",r),e);return ie(t,n)}function Yi(t,e,n){if(n<M)throw new Error("Expected power > 0");if(n===M)return t.ONE;if(n===K)return e;let r=t.ONE,i=e;for(;n>M;)n&K&&(r=t.mul(r,i)),i=t.sqr(i),n>>=K;return r}function Gi(t,e){const n=new Array(e.length),r=e.reduce((o,s,c)=>t.is0(s)?o:(n[c]=o,t.mul(o,s)),t.ONE),i=t.inv(r);return e.reduceRight((o,s,c)=>t.is0(s)?o:(n[c]=t.mul(o,n[c]),t.mul(o,s)),i),n}function Ir(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Oi(t,e,n=!1,r={}){if(t<=M)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:o}=Ir(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Fi(t),c=Object.freeze({ORDER:t,BITS:i,BYTES:o,MASK:xn(i),ZERO:M,ONE:K,create:a=>G(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return M<=a&&a<t},is0:a=>a===M,isOdd:a=>(a&K)===K,neg:a=>G(-a,t),eql:(a,f)=>a===f,sqr:a=>G(a*a,t),add:(a,f)=>G(a+f,t),sub:(a,f)=>G(a-f,t),mul:(a,f)=>G(a*f,t),pow:(a,f)=>Yi(c,a,f),div:(a,f)=>G(a*Xe(f,t),t),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>Xe(a,t),sqrt:r.sqrt||(a=>s(c,a)),invertBatch:a=>Gi(c,a),cmov:(a,f,l)=>l?f:a,toBytes:a=>n?Sn(a,o):Ct(a,o),fromBytes:a=>{if(a.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${a.length}`);return n?En(a):nt(a)}});return Object.freeze(c)}function Tr(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Br(t){const e=Tr(t);return e+Math.ceil(e/2)}function ji(t,e,n=!1){const r=t.length,i=Tr(e),o=Br(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const s=n?nt(t):En(t),c=G(s,e-K)+K;return n?Sn(c,i):Ct(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zi=BigInt(0),Me=BigInt(1);function Qi(t,e){const n=(i,o)=>{const s=o.negate();return i?s:o},r=i=>{const o=Math.ceil(e/i)+1,s=2**(i-1);return{windows:o,windowSize:s}};return{constTimeNegate:n,unsafeLadder(i,o){let s=t.ZERO,c=i;for(;o>Zi;)o&Me&&(s=s.add(c)),c=c.double(),o>>=Me;return s},precomputeWindow(i,o){const{windows:s,windowSize:c}=r(o),a=[];let f=i,l=f;for(let u=0;u<s;u++){l=f,a.push(l);for(let d=1;d<c;d++)l=l.add(f),a.push(l);f=l.double()}return a},wNAF(i,o,s){const{windows:c,windowSize:a}=r(i);let f=t.ZERO,l=t.BASE;const u=BigInt(2**i-1),d=2**i,p=BigInt(i);for(let y=0;y<c;y++){const h=y*a;let g=Number(s&u);s>>=p,g>a&&(g-=d,s+=Me);const w=h,m=h+Math.abs(g)-1,E=y%2!==0,A=g<0;g===0?l=l.add(n(E,o[w])):f=f.add(n(A,o[m]))}return{p:f,f:l}},wNAFCached(i,o,s,c){const a=i._WINDOW_SIZE||1;let f=o.get(i);return f||(f=this.precomputeWindow(i,a),a!==1&&o.set(i,c(f))),this.wNAF(a,f,s)}}}function Ur(t){return Mi(t.Fp),ie(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ir(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Xi(t){const e=Ur(t);ie(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:i}=e;if(n){if(!r.eql(i,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Ji,hexToBytes:to}=Pi,Wt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=Wt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Ji(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=Wt,n=typeof t=="string"?to(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:i,l:o}=Wt._parseInt(n.subarray(2)),{d:s,l:c}=Wt._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(t){const e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,n=f=>{const l=f.toString(16);return l.length&1?`0${l}`:l},r=e(n(t.s)),i=e(n(t.r)),o=r.length/2,s=i.length/2,c=n(o),a=n(s);return`30${n(s+o+4)}02${a}${i}02${c}${r}`}},St=BigInt(0),ht=BigInt(1);BigInt(2);const zn=BigInt(3);BigInt(4);function eo(t){const e=Xi(t),{Fp:n}=e,r=e.toBytes||((y,h,g)=>{const w=h.toAffine();return Pt(Uint8Array.from([4]),n.toBytes(w.x),n.toBytes(w.y))}),i=e.fromBytes||(y=>{const h=y.subarray(1),g=n.fromBytes(h.subarray(0,n.BYTES)),w=n.fromBytes(h.subarray(n.BYTES,2*n.BYTES));return{x:g,y:w}});function o(y){const{a:h,b:g}=e,w=n.sqr(y),m=n.mul(w,y);return n.add(n.add(m,n.mul(y,h)),g)}if(!n.eql(n.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function s(y){return typeof y=="bigint"&&St<y&&y<e.n}function c(y){if(!s(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(y){const{allowedPrivateKeyLengths:h,nByteLength:g,wrapPrivateKey:w,n:m}=e;if(h&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=Gt(y)),typeof y!="string"||!h.includes(y.length))throw new Error("Invalid key");y=y.padStart(g*2,"0")}let E;try{E=typeof y=="bigint"?y:nt(Z("private key",y,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`)}return w&&(E=G(E,m)),c(E),E}const f=new Map;function l(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(h,g,w){if(this.px=h,this.py=g,this.pz=w,h==null||!n.isValid(h))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(w==null||!n.isValid(w))throw new Error("z required")}static fromAffine(h){const{x:g,y:w}=h||{};if(!h||!n.isValid(g)||!n.isValid(w))throw new Error("invalid affine point");if(h instanceof u)throw new Error("projective point not allowed");const m=E=>n.eql(E,n.ZERO);return m(g)&&m(w)?u.ZERO:new u(g,w,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const g=n.invertBatch(h.map(w=>w.pz));return h.map((w,m)=>w.toAffine(g[m])).map(u.fromAffine)}static fromHex(h){const g=u.fromAffine(i(Z("pointHex",h)));return g.assertValidity(),g}static fromPrivateKey(h){return u.BASE.multiply(a(h))}_setWindowSize(h){this._WINDOW_SIZE=h,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:g}=this.toAffine();if(!n.isValid(h)||!n.isValid(g))throw new Error("bad point: x or y not FE");const w=n.sqr(g),m=o(h);if(!n.eql(w,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(n.isOdd)return!n.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){l(h);const{px:g,py:w,pz:m}=this,{px:E,py:A,pz:v}=h,x=n.eql(n.mul(g,v),n.mul(E,m)),k=n.eql(n.mul(w,v),n.mul(A,m));return x&&k}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:h,b:g}=e,w=n.mul(g,zn),{px:m,py:E,pz:A}=this;let v=n.ZERO,x=n.ZERO,k=n.ZERO,I=n.mul(m,m),X=n.mul(E,E),C=n.mul(A,A),U=n.mul(m,E);return U=n.add(U,U),k=n.mul(m,A),k=n.add(k,k),v=n.mul(h,k),x=n.mul(w,C),x=n.add(v,x),v=n.sub(X,x),x=n.add(X,x),x=n.mul(v,x),v=n.mul(U,v),k=n.mul(w,k),C=n.mul(h,C),U=n.sub(I,C),U=n.mul(h,U),U=n.add(U,k),k=n.add(I,I),I=n.add(k,I),I=n.add(I,C),I=n.mul(I,U),x=n.add(x,I),C=n.mul(E,A),C=n.add(C,C),I=n.mul(C,U),v=n.sub(v,I),k=n.mul(C,X),k=n.add(k,k),k=n.add(k,k),new u(v,x,k)}add(h){l(h);const{px:g,py:w,pz:m}=this,{px:E,py:A,pz:v}=h;let x=n.ZERO,k=n.ZERO,I=n.ZERO;const X=e.a,C=n.mul(e.b,zn);let U=n.mul(g,E),it=n.mul(w,A),ot=n.mul(m,v),xt=n.add(g,w),b=n.add(E,A);xt=n.mul(xt,b),b=n.add(U,it),xt=n.sub(xt,b),b=n.add(g,m);let S=n.add(E,v);return b=n.mul(b,S),S=n.add(U,ot),b=n.sub(b,S),S=n.add(w,m),x=n.add(A,v),S=n.mul(S,x),x=n.add(it,ot),S=n.sub(S,x),I=n.mul(X,b),x=n.mul(C,ot),I=n.add(x,I),x=n.sub(it,I),I=n.add(it,I),k=n.mul(x,I),it=n.add(U,U),it=n.add(it,U),ot=n.mul(X,ot),b=n.mul(C,b),it=n.add(it,ot),ot=n.sub(U,ot),ot=n.mul(X,ot),b=n.add(b,ot),U=n.mul(it,b),k=n.add(k,U),U=n.mul(S,b),x=n.mul(xt,x),x=n.sub(x,U),U=n.mul(xt,it),I=n.mul(S,I),I=n.add(I,U),new u(x,k,I)}subtract(h){return this.add(h.negate())}is0(){return this.equals(u.ZERO)}wNAF(h){return p.wNAFCached(this,f,h,g=>{const w=n.invertBatch(g.map(m=>m.pz));return g.map((m,E)=>m.toAffine(w[E])).map(u.fromAffine)})}multiplyUnsafe(h){const g=u.ZERO;if(h===St)return g;if(c(h),h===ht)return this;const{endo:w}=e;if(!w)return p.unsafeLadder(this,h);let{k1neg:m,k1:E,k2neg:A,k2:v}=w.splitScalar(h),x=g,k=g,I=this;for(;E>St||v>St;)E&ht&&(x=x.add(I)),v&ht&&(k=k.add(I)),I=I.double(),E>>=ht,v>>=ht;return m&&(x=x.negate()),A&&(k=k.negate()),k=new u(n.mul(k.px,w.beta),k.py,k.pz),x.add(k)}multiply(h){c(h);let g=h,w,m;const{endo:E}=e;if(E){const{k1neg:A,k1:v,k2neg:x,k2:k}=E.splitScalar(g);let{p:I,f:X}=this.wNAF(v),{p:C,f:U}=this.wNAF(k);I=p.constTimeNegate(A,I),C=p.constTimeNegate(x,C),C=new u(n.mul(C.px,E.beta),C.py,C.pz),w=I.add(C),m=X.add(U)}else{const{p:A,f:v}=this.wNAF(g);w=A,m=v}return u.normalizeZ([w,m])[0]}multiplyAndAddUnsafe(h,g,w){const m=u.BASE,E=(v,x)=>x===St||x===ht||!v.equals(m)?v.multiplyUnsafe(x):v.multiply(x),A=E(this,g).add(E(h,w));return A.is0()?void 0:A}toAffine(h){const{px:g,py:w,pz:m}=this,E=this.is0();h==null&&(h=E?n.ONE:n.inv(m));const A=n.mul(g,h),v=n.mul(w,h),x=n.mul(m,h);if(E)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:A,y:v}}isTorsionFree(){const{h,isTorsionFree:g}=e;if(h===ht)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:g}=e;return h===ht?this:g?g(u,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return this.assertValidity(),r(u,this,h)}toHex(h=!0){return Gt(this.toRawBytes(h))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const d=e.nBitLength,p=Qi(u,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:o,isWithinCurveOrder:s}}function no(t){const e=Ur(t);return ie(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function ro(t){const e=no(t),{Fp:n,n:r}=e,i=n.BYTES+1,o=2*n.BYTES+1;function s(b){return St<b&&b<n.ORDER}function c(b){return G(b,r)}function a(b){return Xe(b,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:l,weierstrassEquation:u,isWithinCurveOrder:d}=eo({...e,toBytes(b,S,T){const L=S.toAffine(),$=n.toBytes(L.x),q=Pt;return T?q(Uint8Array.from([S.hasEvenY()?2:3]),$):q(Uint8Array.from([4]),$,n.toBytes(L.y))},fromBytes(b){const S=b.length,T=b[0],L=b.subarray(1);if(S===i&&(T===2||T===3)){const $=nt(L);if(!s($))throw new Error("Point is not on curve");const q=u($);let st=n.sqrt(q);const ct=(st&ht)===ht;return(T&1)===1!==ct&&(st=n.neg(st)),{x:$,y:st}}else if(S===o&&T===4){const $=n.fromBytes(L.subarray(0,n.BYTES)),q=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:$,y:q}}else throw new Error(`Point of length ${S} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}}),p=b=>Gt(Ct(b,e.nByteLength));function y(b){const S=r>>ht;return b>S}function h(b){return y(b)?c(-b):b}const g=(b,S,T)=>nt(b.slice(S,T));class w{constructor(S,T,L){this.r=S,this.s=T,this.recovery=L,this.assertValidity()}static fromCompact(S){const T=e.nByteLength;return S=Z("compactSignature",S,T*2),new w(g(S,0,T),g(S,T,2*T))}static fromDER(S){const{r:T,s:L}=Wt.toSig(Z("DER",S));return new w(T,L)}assertValidity(){if(!d(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!d(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(S){return new w(this.r,this.s,S)}recoverPublicKey(S){const{r:T,s:L,recovery:$}=this,q=k(Z("msgHash",S));if($==null||![0,1,2,3].includes($))throw new Error("recovery id invalid");const st=$===2||$===3?T+e.n:T;if(st>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const ct=$&1?"03":"02",vt=f.fromHex(ct+p(st)),At=a(st),Vt=c(-q*At),Qt=c(L*At),kt=f.BASE.multiplyAndAddUnsafe(vt,Vt,Qt);if(!kt)throw new Error("point at infinify");return kt.assertValidity(),kt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return Wt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const m={isValidPrivateKey(b){try{return l(b),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const b=Br(e.n);return ji(e.randomBytes(b),e.n)},precompute(b=8,S=f.BASE){return S._setWindowSize(b),S.multiply(BigInt(3)),S}};function E(b,S=!0){return f.fromPrivateKey(b).toRawBytes(S)}function A(b){const S=b instanceof Uint8Array,T=typeof b=="string",L=(S||T)&&b.length;return S?L===i||L===o:T?L===2*i||L===2*o:b instanceof f}function v(b,S,T=!0){if(A(b))throw new Error("first arg must be private key");if(!A(S))throw new Error("second arg must be public key");return f.fromHex(S).multiply(l(b)).toRawBytes(T)}const x=e.bits2int||function(b){const S=nt(b),T=b.length*8-e.nBitLength;return T>0?S>>BigInt(T):S},k=e.bits2int_modN||function(b){return c(x(b))},I=xn(e.nBitLength);function X(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(St<=b&&b<I))throw new Error(`bigint expected < 2^${e.nBitLength}`);return Ct(b,e.nByteLength)}function C(b,S,T=U){if(["recovered","canonical"].some(_t=>_t in T))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:$}=e;let{lowS:q,prehash:st,extraEntropy:ct}=T;q==null&&(q=!0),b=Z("msgHash",b),st&&(b=Z("prehashed msgHash",L(b)));const vt=k(b),At=l(S),Vt=[X(At),X(vt)];if(ct!=null){const _t=ct===!0?$(n.BYTES):ct;Vt.push(Z("extraEntropy",_t))}const Qt=Pt(...Vt),kt=vt;function Ke(_t){const zt=x(_t);if(!d(zt))return;const _n=a(zt),yt=f.BASE.multiply(zt).toAffine(),Ft=c(yt.x);if(Ft===St)return;const ce=c(_n*c(kt+Ft*At));if(ce===St)return;let Hn=(yt.x===Ft?0:2)|Number(yt.y&ht),Dn=ce;return q&&y(ce)&&(Dn=h(ce),Hn^=1),new w(Ft,Dn,Hn)}return{seed:Qt,k2sig:Ke}}const U={lowS:e.lowS,prehash:!1},it={lowS:e.lowS,prehash:!1};function ot(b,S,T=U){const{seed:L,k2sig:$}=C(b,S,T),q=e;return kr(q.hash.outputLen,q.nByteLength,q.hmac)(L,$)}f.BASE._setWindowSize(8);function xt(b,S,T,L=it){const $=b;if(S=Z("msgHash",S),T=Z("publicKey",T),"strict"in L)throw new Error("options.strict was renamed to lowS");const{lowS:q,prehash:st}=L;let ct,vt;try{if(typeof $=="string"||$ instanceof Uint8Array)try{ct=w.fromDER($)}catch(yt){if(!(yt instanceof Wt.Err))throw yt;ct=w.fromCompact($)}else if(typeof $=="object"&&typeof $.r=="bigint"&&typeof $.s=="bigint"){const{r:yt,s:Ft}=$;ct=new w(yt,Ft)}else throw new Error("PARSE");vt=f.fromHex(T)}catch(yt){if(yt.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(q&&ct.hasHighS())return!1;st&&(S=e.hash(S));const{r:At,s:Vt}=ct,Qt=k(S),kt=a(Vt),Ke=c(Qt*kt),_t=c(At*kt),zt=f.BASE.multiplyAndAddUnsafe(vt,Ke,_t)?.toAffine();return zt?c(zt.x)===At:!1}return{CURVE:e,getPublicKey:E,getSharedSecret:v,sign:ot,verify:xt,ProjectivePoint:f,Signature:w,utils:m}}class $r extends mr{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Ei(e);const r=bn(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,o=new Uint8Array(i);o.set(r.length>i?e.create().update(r).digest():r);for(let s=0;s<o.length;s++)o[s]^=54;this.iHash.update(o),this.oHash=e.create();for(let s=0;s<o.length;s++)o[s]^=106;this.oHash.update(o),o.fill(0)}update(e){return pe(this),this.iHash.update(e),this}digestInto(e){pe(this),yr(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:i,destroyed:o,blockLen:s,outputLen:c}=this;return e=e,e.finished=i,e.destroyed=o,e.blockLen=s,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Nr=(t,e,n)=>new $r(t,e).update(n).digest();Nr.create=(t,e)=>new $r(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function io(t){return{hash:t,hmac:(e,...n)=>Nr(t,e,Ai(...n)),randomBytes:Sr}}function oo(t,e){const n=r=>ro({...t,...io(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ue=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ge=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Lr=BigInt(1),we=BigInt(2),Fn=(t,e)=>(t+e/we)/e;function Cr(t){const e=Ue,n=BigInt(3),r=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),c=BigInt(44),a=BigInt(88),f=t*t*t%e,l=f*f*t%e,u=ut(l,n,e)*l%e,d=ut(u,n,e)*l%e,p=ut(d,we,e)*f%e,y=ut(p,i,e)*p%e,h=ut(y,o,e)*y%e,g=ut(h,c,e)*h%e,w=ut(g,a,e)*g%e,m=ut(w,c,e)*h%e,E=ut(m,n,e)*l%e,A=ut(E,s,e)*y%e,v=ut(A,r,e)*f%e,x=ut(v,we,e);if(!Je.eql(Je.sqr(x),t))throw new Error("Cannot find square root");return x}const Je=Oi(Ue,void 0,void 0,{sqrt:Cr}),oe=oo({a:BigInt(0),b:BigInt(7),Fp:Je,n:ge,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ge,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Lr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,s=BigInt("0x100000000000000000000000000000000"),c=Fn(o*t,e),a=Fn(-r*t,e);let f=G(t-c*n-a*i,e),l=G(-c*r-a*o,e);const u=f>s,d=l>s;if(u&&(f=e-f),d&&(l=e-l),f>s||l>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:f,k2neg:d,k2:l}}}},et),$e=BigInt(0),Rr=t=>typeof t=="bigint"&&$e<t&&t<Ue,so=t=>typeof t=="bigint"&&$e<t&&t<ge,qn={};function ye(t,...e){let n=qn[t];if(n===void 0){const r=et(Uint8Array.from(t,i=>i.charCodeAt(0)));n=Pt(r,r),qn[t]=n}return et(Pt(n,...e))}const vn=t=>t.toRawBytes(!0).slice(1),tn=t=>Ct(t,32),Ye=t=>G(t,Ue),re=t=>G(t,ge),An=oe.ProjectivePoint,co=(t,e,n)=>An.BASE.multiplyAndAddUnsafe(t,e,n);function en(t){let e=oe.utils.normPrivateKeyToScalar(t),n=An.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:re(-e),bytes:vn(n)}}function _r(t){if(!Rr(t))throw new Error("bad x: need 0 < x < p");const e=Ye(t*t),n=Ye(e*t+BigInt(7));let r=Cr(n);r%we!==$e&&(r=Ye(-r));const i=new An(t,r,Lr);return i.assertValidity(),i}function Hr(...t){return re(nt(ye("BIP0340/challenge",...t)))}function ao(t){return en(t).bytes}function fo(t,e,n=Sr(32)){const r=Z("message",t),{bytes:i,scalar:o}=en(e),s=Z("auxRand",n,32),c=tn(o^nt(ye("BIP0340/aux",s))),a=ye("BIP0340/nonce",c,i,r),f=re(nt(a));if(f===$e)throw new Error("sign failed: k is zero");const{bytes:l,scalar:u}=en(f),d=Hr(l,i,r),p=new Uint8Array(64);if(p.set(l,0),p.set(tn(re(u+d*o)),32),!Dr(p,r,i))throw new Error("sign: Invalid signature produced");return p}function Dr(t,e,n){const r=Z("signature",t,64),i=Z("message",e),o=Z("publicKey",n,32);try{const s=_r(nt(o)),c=nt(r.subarray(0,32));if(!Rr(c))return!1;const a=nt(r.subarray(32,64));if(!so(a))return!1;const f=Hr(tn(c),vn(s),i),l=co(s,a,re(-f));return!(!l||!l.hasEvenY()||l.toAffine().x!==c)}catch{return!1}}const ft=(()=>({getPublicKey:ao,sign:fo,verify:Dr,utils:{randomPrivateKey:oe.utils.randomPrivateKey,lift_x:_r,pointToBytes:vn,numberToBytesBE:Ct,bytesToNumberBE:nt,taggedHash:ye,mod:G}}))(),lo=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),Wr=Uint8Array.from({length:16},(t,e)=>e),uo=Wr.map(t=>(9*t+5)%16);let kn=[Wr],In=[uo];for(let t=0;t<4;t++)for(let e of[kn,In])e.push(e[t].map(n=>lo[n]));const Pr=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),ho=kn.map((t,e)=>t.map(n=>Pr[e][n])),po=In.map((t,e)=>t.map(n=>Pr[e][n])),go=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),wo=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),ae=(t,e)=>t<<e|t>>>32-e;function Mn(t,e,n,r){return t===0?e^n^r:t===1?e&n|~e&r:t===2?(e|~n)^r:t===3?e&r|n&~r:e^(n|~r)}const fe=new Uint32Array(16);class yo extends xr{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:n,h2:r,h3:i,h4:o}=this;return[e,n,r,i,o]}set(e,n,r,i,o){this.h0=e|0,this.h1=n|0,this.h2=r|0,this.h3=i|0,this.h4=o|0}process(e,n){for(let p=0;p<16;p++,n+=4)fe[p]=e.getUint32(n,!0);let r=this.h0|0,i=r,o=this.h1|0,s=o,c=this.h2|0,a=c,f=this.h3|0,l=f,u=this.h4|0,d=u;for(let p=0;p<5;p++){const y=4-p,h=go[p],g=wo[p],w=kn[p],m=In[p],E=ho[p],A=po[p];for(let v=0;v<16;v++){const x=ae(r+Mn(p,o,c,f)+fe[w[v]]+h,E[v])+u|0;r=u,u=f,f=ae(c,10)|0,c=o,o=x}for(let v=0;v<16;v++){const x=ae(i+Mn(y,s,a,l)+fe[m[v]]+g,A[v])+d|0;i=d,d=l,l=ae(a,10)|0,a=s,s=x}}this.set(this.h1+c+l|0,this.h2+f+d|0,this.h3+u+i|0,this.h4+r+s|0,this.h0+o+a|0)}roundClean(){fe.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const bo=Er(()=>new yo);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ne(...t){const e=(i,o)=>s=>i(o(s)),n=Array.from(t).reverse().reduce((i,o)=>i?e(i,o.encode):o.encode,void 0),r=t.reduce((i,o)=>i?e(i,o.decode):o.decode,void 0);return{encode:n,decode:r}}function Tn(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return e.map(n=>{if(n<0||n>=t.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${t.length})`);return t[n]})},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("alphabet.decode input should be array of strings");return e.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=t.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${t}`);return r})}}}function Bn(t=""){if(typeof t!="string")throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of e)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return e.join(t)},decode:e=>{if(typeof e!="string")throw new Error("join.decode input should be string");return e.split(t)}}}function mo(t){if(typeof t!="function")throw new Error("normalize fn should be function");return{encode:e=>e,decode:e=>t(e)}}function Yn(t,e,n){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let r=0;const i=[],o=Array.from(t);for(o.forEach(s=>{if(s<0||s>=e)throw new Error(`Wrong integer: ${s}`)});;){let s=0,c=!0;for(let a=r;a<o.length;a++){const f=o[a],l=e*s+f;if(!Number.isSafeInteger(l)||e*s/e!==s||l-f!==e*s)throw new Error("convertRadix: carry overflow");s=l%n;const u=Math.floor(l/n);if(o[a]=u,!Number.isSafeInteger(u)||u*n+s!==l)throw new Error("convertRadix: carry overflow");if(c)u?c=!1:r=a;else continue}if(i.push(s),c)break}for(let s=0;s<t.length-1&&t[s]===0;s++)i.push(0);return i.reverse()}const Kr=(t,e)=>e?Kr(e,t%e):t,be=(t,e)=>t+(e-Kr(t,e));function nn(t,e,n,r){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(be(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${be(e,n)}`);let i=0,o=0;const s=2**n-1,c=[];for(const a of t){if(a>=2**e)throw new Error(`convertRadix2: invalid data word=${a} from=${e}`);if(i=i<<e|a,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)c.push((i>>o-n&s)>>>0);i&=2**o-1}if(i=i<<n-o&s,!r&&o>=e)throw new Error("Excess padding");if(!r&&i)throw new Error(`Non-zero padding: ${i}`);return r&&o>0&&c.push(i>>>0),c}function Eo(t){return{encode:e=>{if(!(e instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return Yn(Array.from(e),2**8,t)},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(Yn(e,t,2**8))}}}function Vr(t,e=!1){if(t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(be(8,t)>32||be(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return nn(Array.from(n),8,t,!e)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(nn(n,t,8,e))}}}function Gn(t){if(typeof t!="function")throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch{}}}function So(t,e){if(typeof e!="function")throw new Error("checksum fn should be function");return{encode(n){if(!(n instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const r=e(n).slice(0,t),i=new Uint8Array(n.length+t);return i.set(n),i.set(r,n.length),i},decode(n){if(!(n instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const r=n.slice(0,-t),i=e(r).slice(0,t),o=n.slice(-t);for(let s=0;s<t;s++)if(i[s]!==o[s])throw new Error("Invalid checksum");return r}}}const xo=t=>Ne(Eo(58),Tn(t),Bn("")),vo=xo("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),Ao=t=>Ne(So(4,e=>t(t(e))),vo),rn=Ne(Tn("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Bn("")),On=[996825010,642813549,513874426,1027748829,705979059];function Xt(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<On.length;r++)(e>>r&1)===1&&(n^=On[r]);return n}function jn(t,e,n=1){const r=t.length;let i=1;for(let o=0;o<r;o++){const s=t.charCodeAt(o);if(s<33||s>126)throw new Error(`Invalid prefix (${t})`);i=Xt(i)^s>>5}i=Xt(i);for(let o=0;o<r;o++)i=Xt(i)^t.charCodeAt(o)&31;for(let o of e)i=Xt(i)^o;for(let o=0;o<6;o++)i=Xt(i);return i^=n,rn.encode(nn([i%2**30],30,5,!1))}function zr(t){const e=t==="bech32"?1:734539939,n=Vr(5),r=n.decode,i=n.encode,o=Gn(r);function s(l,u,d=90){if(typeof l!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof l}`);if(!Array.isArray(u)||u.length&&typeof u[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);const p=l.length+7+u.length;if(d!==!1&&p>d)throw new TypeError(`Length ${p} exceeds limit ${d}`);const y=l.toLowerCase(),h=jn(y,u,e);return`${y}1${rn.encode(u)}${h}`}function c(l,u=90){if(typeof l!="string")throw new Error(`bech32.decode input should be string, not ${typeof l}`);if(l.length<8||u!==!1&&l.length>u)throw new TypeError(`Wrong string length: ${l.length} (${l}). Expected (8..${u})`);const d=l.toLowerCase();if(l!==d&&l!==l.toUpperCase())throw new Error("String must be lowercase or uppercase");l=d;const p=l.lastIndexOf("1");if(p===0||p===-1)throw new Error('Letter "1" must be present between prefix and data only');const y=l.slice(0,p),h=l.slice(p+1);if(h.length<6)throw new Error("Data must be at least 6 characters long");const g=rn.decode(h).slice(0,-6),w=jn(y,g,e);if(!h.endsWith(w))throw new Error(`Invalid checksum in ${l}: expected "${w}"`);return{prefix:y,words:g}}const a=Gn(c);function f(l){const{prefix:u,words:d}=c(l,!1);return{prefix:u,words:d,bytes:r(d)}}return{encode:s,decode:c,decodeToBytes:f,decodeUnsafe:a,fromWords:r,fromWordsUnsafe:o,toWords:i}}const on=zr("bech32"),Fr=zr("bech32m"),Zn={encode:t=>new TextDecoder().decode(t),decode:t=>new TextEncoder().encode(t)},P=Ne(Vr(4),Tn("0123456789abcdef"),Bn(""),mo(t=>{if(typeof t!="string"||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),W=new Uint8Array,Un=new Uint8Array([0]);function _(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function sn(...t){if(t.length===1)return t[0];const e=t.reduce((r,i)=>r+i.length,0),n=new Uint8Array(e);for(let r=0,i=0;r<t.length;r++){const o=t[r];n.set(o,i),i+=o.length}return n}const dt=t=>t instanceof Uint8Array;class qr{constructor(e,n=[],r=[]){this.data=e,this.path=n,this.fieldPath=r,this.pos=0,this.hasPtr=!1,this.bitBuf=0,this.bitPos=0}err(e){return new Error(`Reader(${this.fieldPath.join("/")}): ${e}`)}absBytes(e){if(e>this.data.length)throw new Error("absBytes: Unexpected end of buffer");return this.data.subarray(e)}bytes(e,n=!1){if(this.bitPos)throw this.err("readBytes: bitPos not empty");if(!Number.isFinite(e))throw this.err(`readBytes: wrong length=${e}`);if(this.pos+e>this.data.length)throw this.err("readBytes: Unexpected end of buffer");const r=this.data.subarray(this.pos,this.pos+e);return n||(this.pos+=e),r}byte(e=!1){if(this.bitPos)throw this.err("readByte: bitPos not empty");return this.data[e?this.pos:this.pos++]}get leftBytes(){return this.data.length-this.pos}isEnd(){return this.pos>=this.data.length&&!this.bitPos}length(e){let n;if(Rt(e)?n=Number(e.decodeStream(this)):typeof e=="number"?n=e:typeof e=="string"&&(n=Ee(this.path,e.split("/"))),typeof n=="bigint"&&(n=Number(n)),typeof n!="number")throw this.err(`Wrong length: ${n}`);return n}bits(e){if(e>32)throw this.err("BitReader: cannot read more than 32 bits in single call");let n=0;for(;e;){this.bitPos||(this.bitBuf=this.data[this.pos++],this.bitPos=8);const r=Math.min(e,this.bitPos);this.bitPos-=r,n=n<<r|this.bitBuf>>this.bitPos&2**r-1,this.bitBuf&=2**this.bitPos-1,e-=r}return n>>>0}find(e,n=this.pos){if(!dt(e))throw this.err(`find: needle is not bytes! ${e}`);if(this.bitPos)throw this.err("findByte: bitPos not empty");if(!e.length)throw this.err("find: needle is empty");for(let r=n;(r=this.data.indexOf(e[0],r))!==-1;r++){if(r===-1||this.data.length-r<e.length)return;if(_(e,this.data.subarray(r,r+e.length)))return r}}finish(){if(!(this.isEnd()||this.hasPtr))throw this.err(`${this.leftBytes} bytes ${this.bitPos} bits left after unpack: ${P.encode(this.data.slice(this.pos))}`)}fieldPathPush(e){this.fieldPath.push(e)}fieldPathPop(){this.fieldPath.pop()}}class Mr{constructor(e=[],n=[]){this.path=e,this.fieldPath=n,this.buffers=[],this.pos=0,this.ptrs=[],this.bitBuf=0,this.bitPos=0}err(e){return new Error(`Writer(${this.fieldPath.join("/")}): ${e}`)}bytes(e){if(this.bitPos)throw this.err("writeBytes: ends with non-empty bit buffer");this.buffers.push(e),this.pos+=e.length}byte(e){if(this.bitPos)throw this.err("writeByte: ends with non-empty bit buffer");this.buffers.push(new Uint8Array([e])),this.pos++}get buffer(){if(this.bitPos)throw this.err("buffer: ends with non-empty bit buffer");let e=sn(...this.buffers);for(let n of this.ptrs){const r=e.length;e=sn(e,n.buffer);const i=n.ptr.encode(r);for(let o=0;o<i.length;o++)e[n.pos+o]=i[o]}return e}length(e,n){if(e===null)return;if(Rt(e))return e.encodeStream(this,n);let r;if(typeof e=="number"?r=e:typeof e=="string"&&(r=Ee(this.path,e.split("/"))),typeof r=="bigint"&&(r=Number(r)),r===void 0||r!==n)throw this.err(`Wrong length: ${r} len=${e} exp=${n}`)}bits(e,n){if(n>32)throw this.err("writeBits: cannot write more than 32 bits in single call");if(e>=2**n)throw this.err(`writeBits: value (${e}) >= 2**bits (${n})`);for(;n;){const r=Math.min(n,8-this.bitPos);this.bitBuf=this.bitBuf<<r|e>>n-r,this.bitPos+=r,n-=r,e&=2**n-1,this.bitPos===8&&(this.bitPos=0,this.buffers.push(new Uint8Array([this.bitBuf])),this.pos++)}}fieldPathPush(e){this.fieldPath.push(e)}fieldPathPop(){this.fieldPath.pop()}}const me=t=>Uint8Array.from(t).reverse();function Qn(t,e,n,r){if(r){const i=2n**(n-1n);if(e<-i||e>=i)throw t.err("sInt: value out of bounds")}else if(0n>e||e>=2n**n)throw t.err("uInt: value out of bounds")}function Y(t){return{...t,encode:e=>{const n=new Mr;return t.encodeStream(n,e),n.buffer},decode:e=>{const n=new qr(e),r=t.decodeStream(n);return n.finish(),r}}}function Ee(t,e){t=Array.from(t);let n=0;for(;n<e.length&&e[n]==="..";n++)t.pop();let r=t.pop();for(;n<e.length;n++){if(!r||r[e[n]]===void 0)return;r=r[e[n]]}return r}function Rt(t){return typeof t.encode=="function"&&typeof t.encodeStream=="function"&&typeof t.decode=="function"&&typeof t.decodeStream=="function"}function ko(){return{encode:t=>{const e={};for(const[n,r]of t){if(e[n]!==void 0)throw new Error(`coders.dict: same key(${n}) appears twice in struct`);e[n]=r}return e},decode:t=>Object.entries(t)}}const Io={encode:t=>{if(t>BigInt(Number.MAX_SAFE_INTEGER))throw new Error(`coders.number: element bigger than MAX_SAFE_INTEGER=${t}`);return Number(t)},decode:t=>BigInt(t)};function To(t){return{encode:e=>t[e],decode:e=>t[e]}}function Bo(t){const e=10n**BigInt(t);return{encode:n=>{let r=(n<0n?-n:n).toString(10),i=r.length-t;i<0&&(r=r.padStart(r.length-i,"0"),i=0);let o=r.length-1;for(;o>=i&&r[o]==="0";o--);let[s,c]=[r.slice(0,i),r.slice(i,o+1)];return s||(s="0"),n<0n&&(s="-"+s),c?`${s}.${c}`:s},decode:n=>{let r=!1;n.startsWith("-")&&(r=!0,n=n.slice(1));let i=n.indexOf(".");i=i===-1?n.length:i;const[o,s]=[n.slice(0,i),n.slice(i+1)],c=BigInt(o)*e,a=Math.min(s.length,t),f=BigInt(s.slice(0,a))*10n**BigInt(t-a),l=c+f;return r?-l:l}}}function Uo(t){return{encode:e=>{for(const n of t){const r=n.encode(e);if(r!==void 0)return r}throw new Error(`match/encode: cannot find match in ${e}`)},decode:e=>{for(const n of t){const r=n.decode(e);if(r!==void 0)return r}throw new Error(`match/decode: cannot find match in ${e}`)}}}const se={dict:ko,number:Io,tsEnum:To,decimal:Bo,match:Uo},lt=(t,e=!1,n=!1)=>Y({size:t,encodeStream:(r,i)=>{if(typeof i!="number"&&typeof i!="bigint")throw r.err(`bigint: invalid value: ${i}`);let o=BigInt(i);const s=BigInt(t);Qn(r,o,8n*s,!!n);const c=2n**(8n*s-1n);n&&o<0&&(o=o|c);let a=[];for(let l=0;l<t;l++)a.push(Number(o&255n)),o>>=8n;let f=new Uint8Array(a).reverse();r.bytes(e?f.reverse():f)},decodeStream:r=>{const i=BigInt(t);let o=r.bytes(t);e&&(o=me(o));const s=me(o),c=2n**(8n*i-1n);let a=0n;for(let f=0;f<s.length;f++)a|=BigInt(s[f])<<8n*BigInt(f);return n&&a&c&&(a=(a^c)-c),Qn(r,a,8n*i,!!n),a}});lt(32,!0);const $o=lt(32,!1);lt(32,!0,!0);lt(32,!1,!0);lt(16,!0);lt(16,!1);lt(16,!0,!0);lt(16,!1,!0);const he=lt(8,!0);lt(8,!1);const No=lt(8,!0,!0);lt(8,!1,!0);const Et=(t,e=!1,n=!1)=>{if(t>6)throw new Error("int supports size up to 6 bytes (48 bits), for other use bigint");return Ce(lt(t,e,n),se.number)},N=Et(4,!0),Lo=Et(4,!1),te=Et(4,!0,!0);Et(4,!1,!0);const Xn=Et(2,!0);Et(2,!1);Et(2,!0,!0);Et(2,!1,!0);const Lt=Et(1,!1);Et(1,!1,!0);Y({size:1,encodeStream:(t,e)=>t.byte(e?1:0),decodeStream:t=>{const e=t.byte();if(e!==0&&e!==1)throw t.err(`bool: invalid value ${e}`);return e===1}});const D=(t,e=!1)=>Y({size:typeof t=="number"?t:void 0,encodeStream:(n,r)=>{if(!dt(r))throw n.err(`bytes: invalid value ${r}`);dt(t)||n.length(t,r.length),n.bytes(e?me(r):r),dt(t)&&n.bytes(t)},decodeStream:n=>{let r;if(dt(t)){const i=n.find(t);if(!i)throw n.err("bytes: cannot find terminator");r=n.bytes(i-n.pos),n.bytes(t.length)}else r=n.bytes(t===null?n.leftBytes:n.length(t));return e?me(r):r}}),Le=(t,e=!1)=>{const n=D(t,e);return Y({size:n.size,encodeStream:(r,i)=>n.encodeStream(r,Zn.decode(i)),decodeStream:r=>Zn.encode(n.decodeStream(r))})};Le(Un);const Co=(t,e=!1,n=!1)=>{const r=D(t,e);return Y({size:r.size,encodeStream:(i,o)=>{if(n&&!o.startsWith("0x"))throw new Error("hex(withZero=true).encode input should start with 0x");const s=P.decode(n?o.slice(2):o);return r.encodeStream(i,s)},decodeStream:i=>(n?"0x":"")+P.encode(r.decodeStream(i))})};function Ce(t,e){if(!Rt(t))throw new Error(`apply: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(n,r)=>{let i;try{i=e.decode(r)}catch(o){throw n.err(""+o)}return t.encodeStream(n,i)},decodeStream:n=>{const r=t.decodeStream(n);try{return e.encode(r)}catch(i){throw n.err(""+i)}}})}function wt(t,e){if(!Rt(t))throw new Error(`validate: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(n,r)=>t.encodeStream(n,e(r)),decodeStream:n=>e(t.decodeStream(n))})}const Ro=(t,e=!1)=>Y({size:t.length,encodeStream:(n,r)=>{!!r!==e&&n.bytes(t)},decodeStream:n=>{let r=n.leftBytes>=t.length;return r&&(r=_(n.bytes(t.length,!0),t),r&&n.bytes(t.length)),r!==e}});function _o(t,e,n){if(!Rt(e))throw new Error(`flagged: invalid inner value ${e}`);return Y({encodeStream:(r,i)=>{typeof t=="string"?Ee(r.path,t.split("/"))?e.encodeStream(r,i):n&&e.encodeStream(r,n):(t.encodeStream(r,!!i),i?e.encodeStream(r,i):n&&e.encodeStream(r,n))},decodeStream:r=>{let i=!1;if(typeof t=="string"?i=Ee(r.path,t.split("/")):i=t.decodeStream(r),i)return e.decodeStream(r);n&&e.decodeStream(r)}})}function Re(t,e,n=!0){if(!Rt(t))throw new Error(`flagged: invalid inner value ${t}`);return Y({size:t.size,encodeStream:(r,i)=>t.encodeStream(r,e),decodeStream:r=>{const i=t.decodeStream(r);if(n&&typeof i!="object"&&i!==e||dt(e)&&!_(e,i))throw r.err(`magic: invalid value: ${i} !== ${e}`)}})}function Yr(t){let e=0;for(let n of t){if(!n.size)return;e+=n.size}return e}function tt(t){if(Array.isArray(t))throw new Error("Packed.Struct: got array instead of object");return Y({size:Yr(Object.values(t)),encodeStream:(e,n)=>{if(typeof n!="object"||n===null)throw e.err(`struct: invalid value ${n}`);e.path.push(n);for(let r in t)e.fieldPathPush(r),t[r].encodeStream(e,n[r]),e.fieldPathPop();e.path.pop()},decodeStream:e=>{let n={};e.path.push(n);for(let r in t)e.fieldPathPush(r),n[r]=t[r].decodeStream(e),e.fieldPathPop();return e.path.pop(),n}})}function Ho(t){if(!Array.isArray(t))throw new Error(`Packed.Tuple: got ${typeof t} instead of array`);return Y({size:Yr(t),encodeStream:(e,n)=>{if(!Array.isArray(n))throw e.err(`tuple: invalid value ${n}`);e.path.push(n);for(let r=0;r<t.length;r++)e.fieldPathPush(""+r),t[r].encodeStream(e,n[r]),e.fieldPathPop();e.path.pop()},decodeStream:e=>{let n=[];e.path.push(n);for(let r=0;r<t.length;r++)e.fieldPathPush(""+r),n.push(t[r].decodeStream(e)),e.fieldPathPop();return e.path.pop(),n}})}function Do(t,e){if(!Rt(e))throw new Error(`prefix: invalid inner value ${e}`);if(dt(t))throw new Error("prefix: len cannot be Uint8Array");const n=D(t);return Y({size:typeof t=="number"?t:void 0,encodeStream:(r,i)=>{const o=new Mr(r.path,r.fieldPath);e.encodeStream(o,i),n.encodeStream(r,o.buffer)},decodeStream:r=>{const i=n.decodeStream(r);return e.decodeStream(new qr(i,r.path,r.fieldPath))}})}function rt(t,e){if(!Rt(e))throw new Error(`array: invalid inner value ${e}`);return Y({size:typeof t=="number"&&e.size?t*e.size:void 0,encodeStream:(n,r)=>{if(!Array.isArray(r))throw n.err(`array: invalid value ${r}`);dt(t)||n.length(t,r.length),n.path.push(r);for(let i=0;i<r.length;i++){n.fieldPathPush(""+i);const o=r[i],s=n.pos;if(e.encodeStream(n,o),dt(t)){if(t.length>n.pos-s)continue;const c=n.buffer.subarray(s,n.pos);if(_(c.subarray(0,t.length),t))throw n.err(`array: inner element encoding same as separator. elm=${o} data=${c}`)}n.fieldPathPop()}n.path.pop(),dt(t)&&n.bytes(t)},decodeStream:n=>{let r=[];if(t===null){let i=0;for(n.path.push(r);!n.isEnd()&&(n.fieldPathPush(""+i++),r.push(e.decodeStream(n)),n.fieldPathPop(),!(e.size&&n.leftBytes<e.size)););n.path.pop()}else if(dt(t)){let i=0;for(n.path.push(r);;){if(_(n.bytes(t.length,!0),t)){n.bytes(t.length);break}n.fieldPathPush(""+i++),r.push(e.decodeStream(n)),n.fieldPathPop()}n.path.pop()}else{n.fieldPathPush("arrayLen");const i=n.length(t);n.fieldPathPop(),n.path.push(r);for(let o=0;o<i;o++)n.fieldPathPush(""+o),r.push(e.decodeStream(n)),n.fieldPathPop();n.path.pop()}return r}})}Re(D(0),W);/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */const{ProjectivePoint:_e,sign:Jn,getPublicKey:Gr}=oe,Se=oe.CURVE.n,ee=(t,e)=>t===void 0?e:t,H=dt,He=t=>bo(et(t)),Bt=(...t)=>et(et(Ut(...t))),Ut=sn,Or=Ao(et);function xe(t){if(Array.isArray(t))return t.map(e=>xe(e));if(t instanceof Uint8Array)return Uint8Array.from(t);if(["number","bigint","boolean","string","undefined"].includes(typeof t))return t;if(t===null)return t;if(typeof t=="object")return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,xe(n)]));throw new Error(`cloneDeep: unknown type=${t} (${typeof t})`)}var O;(function(t){t[t.ecdsa=0]="ecdsa",t[t.schnorr=1]="schnorr"})(O||(O={}));function jt(t,e){const n=t.length;if(e===O.ecdsa){if(n===32)throw new Error("Expected non-Schnorr key");return _e.fromHex(t),t}else if(e===O.schnorr){if(n!==32)throw new Error("Expected 32-byte Schnorr key");return ft.utils.lift_x(ft.utils.bytesToNumberBE(t)),t}else throw new Error("Unknown key type")}function Nt(t,e){try{return jt(t,e),!0}catch{return!1}}const tr=t=>t.r<Se/2n;function Wo(t,e,n=!1){let r=Jn(t,e);if(n&&!tr(r)){const i=new Uint8Array(32);for(let o=0;o<Number.MAX_SAFE_INTEGER&&(i.set(N.encode(o)),r=Jn(t,e,{extraEntropy:i}),!tr(r));o++);}return r.toDERRawBytes()}function jr(t,e){const n=ft.utils,r=n.taggedHash("TapTweak",t,e),i=n.bytesToNumberBE(r);if(i>=Se)throw new Error("tweak higher than curve order");return i}function Po(t,e=new Uint8Array){const n=ft.utils,r=n.bytesToNumberBE(t),i=_e.fromPrivateKey(r),o=i.hasEvenY()?r:n.mod(-r,Se),s=n.pointToBytes(i),c=jr(s,e);return n.numberToBytesBE(n.mod(o+c,Se),32)}function Zr(t,e){const n=ft.utils,r=jr(t,e),o=n.lift_x(n.bytesToNumberBE(t)).add(_e.fromPrivateKey(r)),s=o.hasEvenY()?0:1;return[n.pointToBytes(o),s]}const cn=wt(D(null),t=>jt(t,O.ecdsa)),ve=wt(D(32),t=>jt(t,O.schnorr)),er=wt(D(null),t=>{if(t.length!==64&&t.length!==65)throw new Error("Schnorr signature should be 64 or 65 bytes long");return t}),Kt={bech32:"bc",pubKeyHash:0,scriptHash:5,wif:128},Us={bech32:"tb",pubKeyHash:111,scriptHash:196,wif:239},Ko=8,Vo=2,Ht=0,Qr=4294967295,le=new Uint8Array(32);se.decimal(Ko);function an(t,e){if(!H(t)||!H(e))throw new Error(`cmp: wrong type a=${typeof t} b=${typeof e}`);const n=Math.min(t.length,e.length);for(let r=0;r<n;r++)if(t[r]!=e[r])return Math.sign(t[r]-e[r]);return Math.sign(t.length-e.length)}var z;(function(t){t[t.OP_0=0]="OP_0",t[t.PUSHDATA1=76]="PUSHDATA1",t[t.PUSHDATA2=77]="PUSHDATA2",t[t.PUSHDATA4=78]="PUSHDATA4",t[t["1NEGATE"]=79]="1NEGATE",t[t.RESERVED=80]="RESERVED",t[t.OP_1=81]="OP_1",t[t.OP_2=82]="OP_2",t[t.OP_3=83]="OP_3",t[t.OP_4=84]="OP_4",t[t.OP_5=85]="OP_5",t[t.OP_6=86]="OP_6",t[t.OP_7=87]="OP_7",t[t.OP_8=88]="OP_8",t[t.OP_9=89]="OP_9",t[t.OP_10=90]="OP_10",t[t.OP_11=91]="OP_11",t[t.OP_12=92]="OP_12",t[t.OP_13=93]="OP_13",t[t.OP_14=94]="OP_14",t[t.OP_15=95]="OP_15",t[t.OP_16=96]="OP_16",t[t.NOP=97]="NOP",t[t.VER=98]="VER",t[t.IF=99]="IF",t[t.NOTIF=100]="NOTIF",t[t.VERIF=101]="VERIF",t[t.VERNOTIF=102]="VERNOTIF",t[t.ELSE=103]="ELSE",t[t.ENDIF=104]="ENDIF",t[t.VERIFY=105]="VERIFY",t[t.RETURN=106]="RETURN",t[t.TOALTSTACK=107]="TOALTSTACK",t[t.FROMALTSTACK=108]="FROMALTSTACK",t[t["2DROP"]=109]="2DROP",t[t["2DUP"]=110]="2DUP",t[t["3DUP"]=111]="3DUP",t[t["2OVER"]=112]="2OVER",t[t["2ROT"]=113]="2ROT",t[t["2SWAP"]=114]="2SWAP",t[t.IFDUP=115]="IFDUP",t[t.DEPTH=116]="DEPTH",t[t.DROP=117]="DROP",t[t.DUP=118]="DUP",t[t.NIP=119]="NIP",t[t.OVER=120]="OVER",t[t.PICK=121]="PICK",t[t.ROLL=122]="ROLL",t[t.ROT=123]="ROT",t[t.SWAP=124]="SWAP",t[t.TUCK=125]="TUCK",t[t.CAT=126]="CAT",t[t.SUBSTR=127]="SUBSTR",t[t.LEFT=128]="LEFT",t[t.RIGHT=129]="RIGHT",t[t.SIZE=130]="SIZE",t[t.INVERT=131]="INVERT",t[t.AND=132]="AND",t[t.OR=133]="OR",t[t.XOR=134]="XOR",t[t.EQUAL=135]="EQUAL",t[t.EQUALVERIFY=136]="EQUALVERIFY",t[t.RESERVED1=137]="RESERVED1",t[t.RESERVED2=138]="RESERVED2",t[t["1ADD"]=139]="1ADD",t[t["1SUB"]=140]="1SUB",t[t["2MUL"]=141]="2MUL",t[t["2DIV"]=142]="2DIV",t[t.NEGATE=143]="NEGATE",t[t.ABS=144]="ABS",t[t.NOT=145]="NOT",t[t["0NOTEQUAL"]=146]="0NOTEQUAL",t[t.ADD=147]="ADD",t[t.SUB=148]="SUB",t[t.MUL=149]="MUL",t[t.DIV=150]="DIV",t[t.MOD=151]="MOD",t[t.LSHIFT=152]="LSHIFT",t[t.RSHIFT=153]="RSHIFT",t[t.BOOLAND=154]="BOOLAND",t[t.BOOLOR=155]="BOOLOR",t[t.NUMEQUAL=156]="NUMEQUAL",t[t.NUMEQUALVERIFY=157]="NUMEQUALVERIFY",t[t.NUMNOTEQUAL=158]="NUMNOTEQUAL",t[t.LESSTHAN=159]="LESSTHAN",t[t.GREATERTHAN=160]="GREATERTHAN",t[t.LESSTHANOREQUAL=161]="LESSTHANOREQUAL",t[t.GREATERTHANOREQUAL=162]="GREATERTHANOREQUAL",t[t.MIN=163]="MIN",t[t.MAX=164]="MAX",t[t.WITHIN=165]="WITHIN",t[t.RIPEMD160=166]="RIPEMD160",t[t.SHA1=167]="SHA1",t[t.SHA256=168]="SHA256",t[t.HASH160=169]="HASH160",t[t.HASH256=170]="HASH256",t[t.CODESEPARATOR=171]="CODESEPARATOR",t[t.CHECKSIG=172]="CHECKSIG",t[t.CHECKSIGVERIFY=173]="CHECKSIGVERIFY",t[t.CHECKMULTISIG=174]="CHECKMULTISIG",t[t.CHECKMULTISIGVERIFY=175]="CHECKMULTISIGVERIFY",t[t.NOP1=176]="NOP1",t[t.CHECKLOCKTIMEVERIFY=177]="CHECKLOCKTIMEVERIFY",t[t.CHECKSEQUENCEVERIFY=178]="CHECKSEQUENCEVERIFY",t[t.NOP4=179]="NOP4",t[t.NOP5=180]="NOP5",t[t.NOP6=181]="NOP6",t[t.NOP7=182]="NOP7",t[t.NOP8=183]="NOP8",t[t.NOP9=184]="NOP9",t[t.NOP10=185]="NOP10",t[t.CHECKSIGADD=186]="CHECKSIGADD",t[t.INVALID=255]="INVALID"})(z||(z={}));const j=Y({encodeStream:(t,e)=>{for(let n of e){if(typeof n=="string"){if(z[n]===void 0)throw new Error(`Unknown opcode=${n}`);t.byte(z[n]);continue}else if(typeof n=="number"){if(n===0){t.byte(0);continue}else if(1<=n&&n<=16){t.byte(z.OP_1-1+n);continue}}if(typeof n=="number"&&(n=Xr().encode(BigInt(n))),!H(n))throw new Error(`Wrong Script OP=${n} (${typeof n})`);const r=n.length;r<z.PUSHDATA1?t.byte(r):r<=255?(t.byte(z.PUSHDATA1),t.byte(r)):r<=65535?(t.byte(z.PUSHDATA2),t.bytes(Xn.encode(r))):(t.byte(z.PUSHDATA4),t.bytes(N.encode(r))),t.bytes(n)}},decodeStream:t=>{const e=[];for(;!t.isEnd();){const n=t.byte();if(z.OP_0<n&&n<=z.PUSHDATA4){let r;if(n<z.PUSHDATA1)r=n;else if(n===z.PUSHDATA1)r=Lt.decodeStream(t);else if(n===z.PUSHDATA2)r=Xn.decodeStream(t);else if(n===z.PUSHDATA4)r=N.decodeStream(t);else throw new Error("Should be not possible");e.push(t.bytes(r))}else if(n===0)e.push(0);else if(z.OP_1<=n&&n<=z.OP_16)e.push(n-(z.OP_1-1));else{const r=z[n];if(r===void 0)throw new Error(`Unknown opcode=${n.toString(16)}`);e.push(r)}}return e}});function Xr(t=6,e=!1){return Y({encodeStream:(n,r)=>{if(r===0n)return;const i=r<0,o=BigInt(r),s=[];for(let c=i?-o:o;c;c>>=8n)s.push(Number(c&0xffn));s[s.length-1]>=128?s.push(i?128:0):i&&(s[s.length-1]|=128),n.bytes(new Uint8Array(s))},decodeStream:n=>{const r=n.leftBytes;if(r>t)throw new Error(`ScriptNum: number (${r}) bigger than limit=${t}`);if(r===0)return 0n;if(e&&!(n.data[r-1]&127)&&(r<=1||!(n.data[r-2]&128)))throw new Error("Non-minimally encoded ScriptNum");let i=0,o=0n;for(let s=0;s<r;++s)i=n.byte(),o|=BigInt(i)<<8n*BigInt(s);return i>=128&&(o&=2n**BigInt(r*8)-1n>>1n,o=-o),o}})}function zo(t,e=4,n=!0){if(typeof t=="number")return t;if(H(t))try{const r=Xr(e,n).decode(t);return r>Number.MAX_SAFE_INTEGER?void 0:Number(r)}catch{return}}const nr={253:[253,2,253n,65535n],254:[254,4,65536n,4294967295n],255:[255,8,4294967296n,18446744073709551615n]},De=Y({encodeStream:(t,e)=>{if(typeof e=="number"&&(e=BigInt(e)),0n<=e&&e<=252n)return t.byte(Number(e));for(const[n,r,i,o]of Object.values(nr))if(!(i>e||e>o)){t.byte(n);for(let s=0;s<r;s++)t.byte(Number(e>>8n*BigInt(s)&0xffn));return}throw t.err(`VarInt too big: ${e}`)},decodeStream:t=>{const e=t.byte();if(e<=252)return BigInt(e);const[n,r,i]=nr[e];let o=0n;for(let s=0;s<r;s++)o|=BigInt(t.byte())<<8n*BigInt(s);if(o<i)throw t.err(`Wrong CompactSize(${8*r})`);return o}}),gt=Ce(De,se.number),rr=t=>rt(De,t),pt=D(De),Fo=tt({txid:D(32,!0),index:N,finalScriptSig:pt,sequence:N}),Mt=tt({amount:he,script:pt}),qo={amount:0xffffffffffffffffn,script:W},$n=rt(gt,pt),Mo=tt({version:te,segwitFlag:Ro(new Uint8Array([0,1])),inputs:rr(Fo),outputs:rr(Mt),witnesses:_o("segwitFlag",rt("inputs/length",$n)),lockTime:N});function Yo(t){if(t.segwitFlag&&t.witnesses&&!t.witnesses.length)throw new Error("Segwit flag with empty witnesses array");return t}const mt=wt(Mo,Yo);function fn(t){const[e,n,r,i,o,s]=t;return{type:e,kc:n,vc:r,reqInc:i,allowInc:o,silentIgnore:s}}const We=tt({fingerprint:Lo,path:rt(null,N)}),Go=tt({version:Lt,internalKey:D(32),merklePath:rt(null,D(32))}),Yt=wt(Go,t=>{if(t.merklePath.length>128)throw new Error("TaprootControlBlock: merklePath should be of length 0..128 (inclusive)");return t}),Jr=tt({hashes:rt(gt,D(32)),der:We}),Oo=D(78),jo=tt({pubKey:ve,leafHash:D(32)}),Zo=rt(null,tt({depth:Lt,version:Lt,script:pt})),F=D(null),ir=D(20),Jt=D(32),Nn={unsignedTx:[0,!1,mt,[0],[0],!1],xpub:[1,Oo,We,[],[0,2],!1],txVersion:[2,!1,N,[2],[2],!1],fallbackLocktime:[3,!1,N,[],[2],!1],inputCount:[4,!1,gt,[2],[2],!1],outputCount:[5,!1,gt,[2],[2],!1],txModifiable:[6,!1,Lt,[],[2],!1],version:[251,!1,N,[],[0,2],!1],proprietary:[252,F,F,[],[0,2],!1]},Ae={nonWitnessUtxo:[0,!1,mt,[],[0,2],!1],witnessUtxo:[1,!1,Mt,[],[0,2],!1],partialSig:[2,cn,F,[],[0,2],!1],sighashType:[3,!1,N,[],[0,2],!1],redeemScript:[4,!1,F,[],[0,2],!1],witnessScript:[5,!1,F,[],[0,2],!1],bip32Derivation:[6,cn,We,[],[0,2],!1],finalScriptSig:[7,!1,F,[],[0,2],!1],finalScriptWitness:[8,!1,$n,[],[0,2],!1],porCommitment:[9,!1,F,[],[0,2],!1],ripemd160:[10,ir,F,[],[0,2],!1],sha256:[11,Jt,F,[],[0,2],!1],hash160:[12,ir,F,[],[0,2],!1],hash256:[13,Jt,F,[],[0,2],!1],txid:[14,!1,Jt,[2],[2],!0],index:[15,!1,N,[2],[2],!0],sequence:[16,!1,N,[],[2],!0],requiredTimeLocktime:[17,!1,N,[],[2],!1],requiredHeightLocktime:[18,!1,N,[],[2],!1],tapKeySig:[19,!1,er,[],[0,2],!1],tapScriptSig:[20,jo,er,[],[0,2],!1],tapLeafScript:[21,Yt,F,[],[0,2],!1],tapBip32Derivation:[22,Jt,Jr,[],[0,2],!1],tapInternalKey:[23,!1,ve,[],[0,2],!1],tapMerkleRoot:[24,!1,Jt,[],[0,2],!1],proprietary:[252,F,F,[],[0,2],!1]},Qo=["txid","sequence","index","witnessUtxo","nonWitnessUtxo","finalScriptSig","finalScriptWitness","unknown"],Xo=["partialSig","finalScriptSig","finalScriptWitness","tapKeySig","tapScriptSig"],ke={redeemScript:[0,!1,F,[],[0,2],!1],witnessScript:[1,!1,F,[],[0,2],!1],bip32Derivation:[2,cn,We,[],[0,2],!1],amount:[3,!1,No,[2],[2],!0],script:[4,!1,F,[2],[2],!0],tapInternalKey:[5,!1,ve,[],[0,2],!1],tapTree:[6,!1,Zo,[],[0,2],!1],tapBip32Derivation:[7,ve,Jr,[],[0,2],!1],proprietary:[252,F,F,[],[0,2],!1]},Jo=[],or=rt(Un,tt({key:Do(gt,tt({type:gt,key:D(null)})),value:D(gt)}));tt({type:gt,key:D(null)});function Ln(t){const e={};for(const n in t){const[r,i,o]=t[n];e[r]=[n,i,o]}return Y({encodeStream:(n,r)=>{let i=[];for(const o in t){const s=r[o];if(s===void 0)continue;const[c,a,f]=t[o];if(!a)i.push({key:{type:c,key:W},value:f.encode(s)});else{const l=s.map(([u,d])=>[a.encode(u),f.encode(d)]);l.sort((u,d)=>an(u[0],d[0]));for(const[u,d]of l)i.push({key:{key:u,type:c},value:d})}}if(r.unknown){r.unknown.sort((o,s)=>an(o[0].key,s[0].key));for(const[o,s]of r.unknown)i.push({key:o,value:s})}or.encodeStream(n,i)},decodeStream:n=>{const r=or.decodeStream(n),i={},o={};for(const s of r){let c="unknown",a=s.key.key,f=s.value;if(e[s.key.type]){const[l,u,d]=e[s.key.type];if(c=l,!u&&a.length)throw new Error(`PSBT: Non-empty key for ${c} (key=${P.encode(a)} value=${P.encode(f)}`);if(a=u?u.decode(a):void 0,f=d.decode(f),!u){if(i[c])throw new Error(`PSBT: Same keys: ${c} (key=${a} value=${f})`);i[c]=f,o[c]=!0;continue}}else a={type:s.key.type,key:s.key.key};if(o[c])throw new Error(`PSBT: Key type with empty key and no key=${c} val=${f}`);i[c]||(i[c]=[]),i[c].push([a,f])}return i}})}function sr(t,e){if(!_(t.hash,et(e)))throw new Error("checkScript: wsh wrong witnessScript hash");const n=Q.decode(e);if(n.type==="tr"||n.type==="tr_ns"||n.type==="tr_ms")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2SH`);if(n.type==="wpkh"||n.type==="sh")throw new Error(`checkScript: P2${n.type} cannot be wrapped in P2WSH`)}function cr(t,e,n){if(t){const r=Q.decode(t);if(r.type==="tr_ns"||r.type==="tr_ms"||r.type==="ms"||r.type=="pk")throw new Error(`checkScript: non-wrapped ${r.type}`);if(r.type==="sh"&&e){if(!_(r.hash,He(e)))throw new Error("checkScript: sh wrong redeemScript hash");const i=Q.decode(e);if(i.type==="tr"||i.type==="tr_ns"||i.type==="tr_ms")throw new Error(`checkScript: P2${i.type} cannot be wrapped in P2SH`);if(i.type==="sh")throw new Error("checkScript: P2SH cannot be wrapped in P2SH")}r.type==="wsh"&&n&&sr(r,n)}if(e){const r=Q.decode(e);r.type==="wsh"&&n&&sr(r,n)}}const Cn=wt(Ln(Ae),t=>{if(t.finalScriptWitness&&!t.finalScriptWitness.length)throw new Error("validateInput: wmpty finalScriptWitness");if(t.partialSig&&!t.partialSig.length)throw new Error("Empty partialSig");if(t.partialSig)for(const[e]of t.partialSig)jt(e,O.ecdsa);if(t.bip32Derivation)for(const[e]of t.bip32Derivation)jt(e,O.ecdsa);if(t.requiredTimeLocktime!==void 0&&t.requiredTimeLocktime<5e8)throw new Error(`validateInput: wrong timeLocktime=${t.requiredTimeLocktime}`);if(t.requiredHeightLocktime!==void 0&&(t.requiredHeightLocktime<=0||t.requiredHeightLocktime>=5e8))throw new Error(`validateInput: wrong heighLocktime=${t.requiredHeightLocktime}`);if(t.nonWitnessUtxo&&t.index!==void 0){const e=t.nonWitnessUtxo.outputs.length-1;if(t.index>e)throw new Error(`validateInput: index(${t.index}) not in nonWitnessUtxo`);const n=t.nonWitnessUtxo.outputs[t.index];if(t.witnessUtxo&&(!_(t.witnessUtxo.script,n.script)||t.witnessUtxo.amount!==n.amount))throw new Error("validateInput: witnessUtxo different from nonWitnessUtxo")}if(t.tapLeafScript)for(const[e,n]of t.tapLeafScript){if((e.version&254)!==n[n.length-1])throw new Error("validateInput: tapLeafScript version mimatch");if(n[n.length-1]&1)throw new Error("validateInput: tapLeafScript version has parity bit!")}if(t.nonWitnessUtxo&&t.index&&t.txid){if(t.nonWitnessUtxo.outputs.length-1<t.index)throw new Error("nonWitnessUtxo: incorect output index");const n=ne.fromRaw(mt.encode(t.nonWitnessUtxo)),r=P.encode(t.txid);if(n.id!==r)throw new Error(`nonWitnessUtxo: wrong txid, exp=${r} got=${n.id}`)}return t}),Rn=wt(Ln(ke),t=>{if(t.bip32Derivation)for(const[e]of t.bip32Derivation)jt(e,O.ecdsa);return t}),ti=wt(Ln(Nn),t=>{if((t.version||0)===0){if(!t.unsignedTx)throw new Error("PSBTv0: missing unsignedTx");if(t.unsignedTx.segwitFlag||t.unsignedTx.witnesses)throw new Error("PSBTv0: witness in unsingedTx");for(const n of t.unsignedTx.inputs)if(n.finalScriptSig&&n.finalScriptSig.length)throw new Error("PSBTv0: input scriptSig found in unsignedTx")}return t}),ts=tt({magic:Re(Le(new Uint8Array([255])),"psbt"),global:ti,inputs:rt("global/unsignedTx/inputs/length",Cn),outputs:rt(null,Rn)}),es=tt({magic:Re(Le(new Uint8Array([255])),"psbt"),global:ti,inputs:rt("global/inputCount",Cn),outputs:rt("global/outputCount",Rn)});tt({magic:Re(Le(new Uint8Array([255])),"psbt"),items:rt(null,Ce(rt(Un,Ho([Co(gt),D(De)])),se.dict()))});function Ge(t,e,n){for(const r in n){if(r==="unknown"||!e[r])continue;const{allowInc:i}=fn(e[r]);if(!i.includes(t))throw new Error(`PSBTv${t}: field ${r} is not allowed`)}for(const r in e){const{reqInc:i}=fn(e[r]);if(i.includes(t)&&n[r]===void 0)throw new Error(`PSBTv${t}: missing required field ${r}`)}}function ar(t,e,n){const r={};for(const i in n){const o=i;if(o!=="unknown"){if(!e[o])continue;const{allowInc:s,silentIgnore:c}=fn(e[o]);if(!s.includes(t)){if(c)continue;throw new Error(`Failed to serialize in PSBTv${t}: ${o} but versions allows inclusion=${s}`)}}r[o]=n[o]}return r}function ei(t){const e=t&&t.global&&t.global.version||0;Ge(e,Nn,t.global);for(const s of t.inputs)Ge(e,Ae,s);for(const s of t.outputs)Ge(e,ke,s);const n=e?t.global.inputCount:t.global.unsignedTx.inputs.length;if(t.inputs.length<n)throw new Error("Not enough inputs");const r=t.inputs.slice(n);if(r.length>1||r.length&&Object.keys(r[0]).length)throw new Error(`Unexpected inputs left in tx=${r}`);const i=e?t.global.outputCount:t.global.unsignedTx.outputs.length;if(t.outputs.length<i)throw new Error("Not outputs inputs");const o=t.outputs.slice(i);if(o.length>1||o.length&&Object.keys(o[0]).length)throw new Error(`Unexpected outputs left in tx=${o}`);return t}function Oe(t,e,n,r){const i={...n,...e};for(const o in t){const s=o,[c,a,f]=t[s],l=r&&!r.includes(o);if(e[o]===void 0&&o in e){if(l)throw new Error(`Cannot remove signed field=${o}`);delete i[o]}else if(a){const u=n&&n[o]?n[o]:[];let d=e[s];if(d){if(!Array.isArray(d))throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);d=d.map(h=>{if(h.length!==2)throw new Error(`keyMap(${o}): KV pairs should be [k, v][]`);return[typeof h[0]=="string"?a.decode(P.decode(h[0])):h[0],typeof h[1]=="string"?f.decode(P.decode(h[1])):h[1]]});const p={},y=(h,g,w)=>{if(p[h]===void 0){p[h]=[g,w];return}const m=P.encode(f.encode(p[h][1])),E=P.encode(f.encode(w));if(m!==E)throw new Error(`keyMap(${s}): same key=${h} oldVal=${m} newVal=${E}`)};for(const[h,g]of u){const w=P.encode(a.encode(h));y(w,h,g)}for(const[h,g]of d){const w=P.encode(a.encode(h));if(g===void 0){if(l)throw new Error(`Cannot remove signed field=${s}/${h}`);delete p[w]}else y(w,h,g)}i[s]=Object.values(p)}}else if(typeof i[o]=="string")i[o]=f.decode(P.decode(i[o]));else if(l&&o in e&&n&&n[o]!==void 0&&!_(f.encode(e[o]),f.encode(n[o])))throw new Error(`Cannot change signed field=${o}`)}for(const o in i)t[o]||delete i[o];return i}const fr=wt(ts,ei),lr=wt(es,ei),je=tt({txid:D(32,!0),index:N}),ns={encode(t){if(!(t.length!==2||!H(t[0])||!Nt(t[0],O.ecdsa)||t[1]!=="CHECKSIG"))return{type:"pk",pubkey:t[0]}},decode:t=>t.type==="pk"?[t.pubkey,"CHECKSIG"]:void 0},rs={encode(t){if(!(t.length!==5||t[0]!=="DUP"||t[1]!=="HASH160"||!H(t[2]))&&!(t[3]!=="EQUALVERIFY"||t[4]!=="CHECKSIG"))return{type:"pkh",hash:t[2]}},decode:t=>t.type==="pkh"?["DUP","HASH160",t.hash,"EQUALVERIFY","CHECKSIG"]:void 0},is=(t,e=Kt)=>{if(!Nt(t,O.ecdsa))throw new Error("P2PKH: invalid publicKey");const n=He(t);return{type:"pkh",script:Q.encode({type:"pkh",hash:n}),address:Pe(e).encode({type:"pkh",hash:n})}},os={encode(t){if(!(t.length!==3||t[0]!=="HASH160"||!H(t[1])||t[2]!=="EQUAL"))return{type:"sh",hash:t[1]}},decode:t=>t.type==="sh"?["HASH160",t.hash,"EQUAL"]:void 0},ss={encode(t){if(!(t.length!==2||t[0]!==0||!H(t[1]))&&t[1].length===32)return{type:"wsh",hash:t[1]}},decode:t=>t.type==="wsh"?[0,t.hash]:void 0},cs={encode(t){if(!(t.length!==2||t[0]!==0||!H(t[1]))&&t[1].length===20)return{type:"wpkh",hash:t[1]}},decode:t=>t.type==="wpkh"?[0,t.hash]:void 0},as=(t,e=Kt)=>{if(!Nt(t,O.ecdsa))throw new Error("P2WPKH: invalid publicKey");if(t.length===65)throw new Error("P2WPKH: uncompressed public key");const n=He(t);return{type:"wpkh",script:Q.encode({type:"wpkh",hash:n}),address:Pe(e).encode({type:"wpkh",hash:n})}},fs={encode(t){const e=t.length-1;if(t[e]!=="CHECKMULTISIG")return;const n=t[0],r=t[e-1];if(typeof n!="number"||typeof r!="number")return;const i=t.slice(1,-2);if(r===i.length){for(const o of i)if(!H(o))return;return{type:"ms",m:n,pubkeys:i}}},decode:t=>t.type==="ms"?[t.m,...t.pubkeys,t.pubkeys.length,"CHECKMULTISIG"]:void 0},ls={encode(t){if(!(t.length!==2||t[0]!==1||!H(t[1])))return{type:"tr",pubkey:t[1]}},decode:t=>t.type==="tr"?[1,t.pubkey]:void 0};function us(t){const e=Array.from(t);for(;e.length>=2;){e.sort((s,c)=>(c.weight||1)-(s.weight||1));const r=e.pop(),i=e.pop(),o=(i?.weight||1)+(r?.weight||1);e.push({weight:o,childs:[i?.childs||i,r?.childs||r]})}const n=e[0];return n?.childs||n}function hs(t,e,n=!1){const r=Q.decode(t);if(r.type==="unknown"&&n)return;if(!["tr_ns","tr_ms"].includes(r.type))throw new Error(`P2TR: invalid leaf script=${r.type}`);const i=r;if(!n&&i.pubkeys)for(const o of i.pubkeys){if(_(o,ni))throw new Error("Unspendable taproot key in leaf script");if(_(o,e))throw new Error("Using P2TR with leaf script with same key as internal key is not supported")}}function ln(t,e,n=!1){if(!t)throw new Error("taprootHashTree: empty tree");if(Array.isArray(t)&&t.length===1&&(t=t[0]),!Array.isArray(t)){const{leafVersion:c,script:a}=t;if(t.tapLeafScript||t.tapMerkleRoot&&!_(t.tapMerkleRoot,W))throw new Error("P2TR: tapRoot leafScript cannot have tree");const f=typeof a=="string"?P.decode(a):a;if(!H(f))throw new Error(`checkScript: wrong script type=${f}`);return hs(f,e,n),{type:"leaf",version:c,script:f,hash:de(f,c)}}if(t.length!==2&&(t=us(t)),t.length!==2)throw new Error("hashTree: non binary tree!");const r=ln(t[0],e,n),i=ln(t[1],e,n);let[o,s]=[r.hash,i.hash];return an(s,o)===-1&&([o,s]=[s,o]),{type:"branch",left:r,right:i,hash:ft.utils.taggedHash("TapBranch",o,s)}}function un(t,e=[]){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return{...t,path:e};if(t.type!=="branch")throw new Error(`taprootAddPath: wrong type=${t}`);return{...t,path:e,left:un(t.left,[t.right.hash,...e]),right:un(t.right,[t.left.hash,...e])}}function hn(t){if(!t)throw new Error("taprootAddPath: empty tree");if(t.type==="leaf")return[t];if(t.type!=="branch")throw new Error(`taprootWalkTree: wrong type=${t}`);return[...hn(t.left),...hn(t.right)]}const ni=et(_e.BASE.toRawBytes(!1));function ds(t,e,n=Kt,r=!1){if(!t&&!e)throw new Error("p2tr: should have pubKey or scriptTree (or both)");const i=typeof t=="string"?P.decode(t):t||ni;if(!Nt(i,O.schnorr))throw new Error("p2tr: non-schnorr pubkey");let o=e?un(ln(e,i,r)):void 0;const s=o?o.hash:void 0,[c,a]=Zr(i,s||W);let f;o&&(f=hn(o).map(d=>({...d,controlBlock:Yt.encode({version:(d.version||pn)+a,internalKey:i,merklePath:d.path})})));let l;f&&(l=f.map(d=>[Yt.decode(d.controlBlock),Ut(d.script,new Uint8Array([d.version||pn]))]));const u={type:"tr",script:Q.encode({type:"tr",pubkey:c}),address:Pe(n).encode({type:"tr",pubkey:c}),tweakedPubkey:c,tapInternalKey:i};return f&&(u.leaves=f),l&&(u.tapLeafScript=l),s&&(u.tapMerkleRoot=s),u}const ps={encode(t){const e=t.length-1;if(t[e]!=="CHECKSIG")return;const n=[];for(let r=0;r<e;r++){const i=t[r];if(r&1){if(i!=="CHECKSIGVERIFY"||r===e-1)return;continue}if(!H(i))return;n.push(i)}return{type:"tr_ns",pubkeys:n}},decode:t=>{if(t.type!=="tr_ns")return;const e=[];for(let n=0;n<t.pubkeys.length-1;n++)e.push(t.pubkeys[n],"CHECKSIGVERIFY");return e.push(t.pubkeys[t.pubkeys.length-1],"CHECKSIG"),e}},gs={encode(t){const e=t.length-1;if(t[e]!=="NUMEQUAL"||t[1]!=="CHECKSIG")return;const n=[],r=zo(t[e-1]);if(typeof r=="number"){for(let i=0;i<e-1;i++){const o=t[i];if(i&1){if(o!==(i===1?"CHECKSIG":"CHECKSIGADD"))throw new Error("OutScript.encode/tr_ms: wrong element");continue}if(!H(o))throw new Error("OutScript.encode/tr_ms: wrong key element");n.push(o)}return{type:"tr_ms",pubkeys:n,m:r}}},decode:t=>{if(t.type!=="tr_ms")return;const e=[t.pubkeys[0],"CHECKSIG"];for(let n=1;n<t.pubkeys.length;n++)e.push(t.pubkeys[n],"CHECKSIGADD");return e.push(t.m,"NUMEQUAL"),e}},ws={encode(t){return{type:"unknown",script:j.encode(t)}},decode:t=>t.type==="unknown"?j.decode(t.script):void 0},ys=[ns,rs,os,ss,cs,fs,ls,ps,gs,ws],bs=Ce(j,se.match(ys)),Q=wt(bs,t=>{if(t.type==="pk"&&!Nt(t.pubkey,O.ecdsa))throw new Error("OutScript/pk: wrong key");if((t.type==="pkh"||t.type==="sh"||t.type==="wpkh")&&(!H(t.hash)||t.hash.length!==20))throw new Error(`OutScript/${t.type}: wrong hash`);if(t.type==="wsh"&&(!H(t.hash)||t.hash.length!==32))throw new Error("OutScript/wsh: wrong hash");if(t.type==="tr"&&(!H(t.pubkey)||!Nt(t.pubkey,O.schnorr)))throw new Error("OutScript/tr: wrong taproot public key");if((t.type==="ms"||t.type==="tr_ns"||t.type==="tr_ms")&&!Array.isArray(t.pubkeys))throw new Error("OutScript/multisig: wrong pubkeys array");if(t.type==="ms"){const e=t.pubkeys.length;for(const n of t.pubkeys)if(!Nt(n,O.ecdsa))throw new Error("OutScript/multisig: wrong pubkey");if(t.m<=0||e>16||t.m>e)throw new Error("OutScript/multisig: invalid params")}if(t.type==="tr_ns"||t.type==="tr_ms"){for(const e of t.pubkeys)if(!Nt(e,O.schnorr))throw new Error(`OutScript/${t.type}: wrong pubkey`)}if(t.type==="tr_ms"){const e=t.pubkeys.length;if(t.m<=0||e>999||t.m>e)throw new Error("OutScript/tr_ms: invalid params")}return t});function ri(t,e){if(e.length<2||e.length>40)throw new Error("Witness: invalid length");if(t>16)throw new Error("Witness: invalid version");if(t===0&&!(e.length===20||e.length===32))throw new Error("Witness: invalid length for version")}function Ze(t,e,n=Kt){ri(t,e);const r=t===0?on:Fr;return r.encode(n.bech32,[t].concat(r.toWords(e)))}function ur(t,e){return Or.encode(Ut(Uint8Array.from(e),t))}function Pe(t=Kt){return{encode(e){const{type:n}=e;if(n==="wpkh")return Ze(0,e.hash,t);if(n==="wsh")return Ze(0,e.hash,t);if(n==="tr")return Ze(1,e.pubkey,t);if(n==="pkh")return ur(e.hash,[t.pubKeyHash]);if(n==="sh")return ur(e.hash,[t.scriptHash]);throw new Error(`Unknown address type=${n}`)},decode(e){if(e.length<14||e.length>74)throw new Error("Invalid address length");if(t.bech32&&e.toLowerCase().startsWith(t.bech32)){let r;try{if(r=on.decode(e),r.words[0]!==0)throw new Error(`bech32: wrong version=${r.words[0]}`)}catch{if(r=Fr.decode(e),r.words[0]===0)throw new Error(`bech32m: wrong version=${r.words[0]}`)}if(r.prefix!==t.bech32)throw new Error(`wrong bech32 prefix=${r.prefix}`);const[i,...o]=r.words,s=on.fromWords(o);if(ri(i,s),i===0&&s.length===32)return{type:"wsh",hash:s};if(i===0&&s.length===20)return{type:"wpkh",hash:s};if(i===1&&s.length===32)return{type:"tr",pubkey:s};throw new Error("Unknown witness program")}const n=Or.decode(e);if(n.length!==21)throw new Error("Invalid base58 address");if(n[0]===t.pubKeyHash)return{type:"pkh",hash:n.slice(1)};if(n[0]===t.scriptHash)return{type:"sh",hash:n.slice(1)};throw new Error(`Invalid address prefix=${n[0]}`)}}}var R;(function(t){t[t.DEFAULT=0]="DEFAULT",t[t.ALL=1]="ALL",t[t.NONE=2]="NONE",t[t.SINGLE=3]="SINGLE",t[t.ANYONECANPAY=128]="ANYONECANPAY"})(R||(R={}));var dn;(function(t){t[t.DEFAULT=0]="DEFAULT",t[t.ALL=1]="ALL",t[t.NONE=2]="NONE",t[t.SINGLE=3]="SINGLE",t[t.DEFAULT_ANYONECANPAY=128]="DEFAULT_ANYONECANPAY",t[t.ALL_ANYONECANPAY=129]="ALL_ANYONECANPAY",t[t.NONE_ANYONECANPAY=130]="NONE_ANYONECANPAY",t[t.SINGLE_ANYONECANPAY=131]="SINGLE_ANYONECANPAY"})(dn||(dn={}));function ms(t){if(typeof t!="number"||typeof dn[t]!="string")throw new Error(`Invalid SigHash=${t}`);return t}function hr(t){const e=t&31;return{isAny:!!(t&R.ANYONECANPAY),isNone:e===R.NONE,isSingle:e===R.SINGLE}}function ue(t){if(t.txid===void 0||t.index===void 0)throw new Error("Transaction/input: txid and index required");return{txid:t.txid,index:t.index,sequence:ee(t.sequence,Qr),finalScriptSig:ee(t.finalScriptSig,W)}}function dr(t){for(const e in t){const n=e;Qo.includes(n)||delete t[n]}}function qt(t){if(t.script===void 0||t.amount===void 0)throw new Error("Transaction/output: script and amount required");return{script:t.script,amount:t.amount}}const pn=192,de=(t,e=pn)=>ft.utils.taggedHash("TapLeaf",new Uint8Array([e]),pt.encode(t));function Es(t,e,n,r=W){return _(n,e)&&(t=Po(t,r),e=ft.getPublicKey(t)),{privKey:t,pubKey:e}}const Ss={}.toString;function xs(t){if(t!==void 0&&Ss.call(t)!=="[object Object]")throw new Error(`Wrong object type for transaction options: ${t}`);const e={...t,version:ee(t.version,Vo),lockTime:ee(t.lockTime,0),PSBTVersion:ee(t.PSBTVersion,0)};if(typeof e.allowUnknowInput<"u"&&(t.allowUnknownInputs=e.allowUnknowInput),typeof e.allowUnknowOutput<"u"&&(t.allowUnknownOutputs=e.allowUnknowOutput),![-1,0,1,2].includes(e.version))throw new Error(`Unknown version: ${e.version}`);if(typeof e.lockTime!="number")throw new Error("Transaction lock time should be number");if(N.encode(e.lockTime),e.PSBTVersion!==0&&e.PSBTVersion!==2)throw new Error(`Unknown PSBT version ${e.PSBTVersion}`);for(const n of["allowUnknownOutputs","allowUnknownInputs","disableScriptCheck","bip174jsCompat","allowLegacyWitnessUtxo","lowR"]){const r=e[n];if(r!==void 0&&typeof r!="boolean")throw new Error(`Transation options wrong type: ${n}=${r} (${typeof r})`)}return Object.freeze(e)}class ne{constructor(e={}){this.global={},this.inputs=[],this.outputs=[];const n=this.opts=xs(e);n.lockTime!==Ht&&(this.global.fallbackLocktime=n.lockTime),this.global.txVersion=n.version}static fromRaw(e,n={}){const r=mt.decode(e),i=new ne({...n,version:r.version,lockTime:r.lockTime});for(const o of r.outputs)i.addOutput(o);if(i.outputs=r.outputs,i.inputs=r.inputs,r.witnesses)for(let o=0;o<r.witnesses.length;o++)i.inputs[o].finalScriptWitness=r.witnesses[o];return i}static fromPSBT(e,n={}){let r;try{r=fr.decode(e)}catch(u){try{r=lr.decode(e)}catch{throw u}}const i=r.global.version||0;if(i!==0&&i!==2)throw new Error(`Wrong PSBT version=${i}`);const o=r.global.unsignedTx,s=i===0?o?.version:r.global.txVersion,c=i===0?o?.lockTime:r.global.fallbackLocktime,a=new ne({...n,version:s,lockTime:c,PSBTVersion:i}),f=i===0?o?.inputs.length:r.global.inputCount;a.inputs=r.inputs.slice(0,f).map((u,d)=>({finalScriptSig:W,...r.global.unsignedTx?.inputs[d],...u}));const l=i===0?o?.outputs.length:r.global.outputCount;return a.outputs=r.outputs.slice(0,l).map((u,d)=>({...u,...r.global.unsignedTx?.outputs[d]})),a.global={...r.global,txVersion:s},c!==Ht&&(a.global.fallbackLocktime=c),a}toPSBT(e=this.opts.PSBTVersion){if(e!==0&&e!==2)throw new Error(`Wrong PSBT version=${e}`);const n=this.inputs.map(o=>ar(e,Ae,o));for(const o of n)o.partialSig&&!o.partialSig.length&&delete o.partialSig,o.finalScriptSig&&!o.finalScriptSig.length&&delete o.finalScriptSig,o.finalScriptWitness&&!o.finalScriptWitness.length&&delete o.finalScriptWitness;const r=this.outputs.map(o=>ar(e,ke,o)),i={...this.global};return e===0?(i.unsignedTx=mt.decode(this.unsignedTx),delete i.fallbackLocktime,delete i.txVersion):(i.version=e,i.txVersion=this.version,i.inputCount=this.inputs.length,i.outputCount=this.outputs.length,i.fallbackLocktime&&i.fallbackLocktime===Ht&&delete i.fallbackLocktime),this.opts.bip174jsCompat&&(n.length||n.push({}),r.length||r.push({})),(e===0?fr:lr).encode({global:i,inputs:n,outputs:r})}get lockTime(){let e=Ht,n=0,r=Ht,i=0;for(const o of this.inputs)o.requiredHeightLocktime&&(e=Math.max(e,o.requiredHeightLocktime),n++),o.requiredTimeLocktime&&(r=Math.max(r,o.requiredTimeLocktime),i++);return n&&n>=i?e:r!==Ht?r:this.global.fallbackLocktime||Ht}get version(){if(this.global.txVersion===void 0)throw new Error("No global.txVersion");return this.global.txVersion}inputStatus(e){this.checkInputIdx(e);const n=this.inputs[e];return n.finalScriptSig&&n.finalScriptSig.length||n.finalScriptWitness&&n.finalScriptWitness.length?"finalized":n.tapKeySig||n.tapScriptSig&&n.tapScriptSig.length||n.partialSig&&n.partialSig.length?"signed":"unsigned"}inputSighash(e){this.checkInputIdx(e);const n=this.inputType(this.inputs[e]).sighash,r=n===R.DEFAULT?R.ALL:n&3;return{sigInputs:n&R.ANYONECANPAY,sigOutputs:r}}signStatus(){let e=!0,n=!0,r=[],i=[];for(let o=0;o<this.inputs.length;o++){if(this.inputStatus(o)==="unsigned")continue;const{sigInputs:c,sigOutputs:a}=this.inputSighash(o);if(c===R.ANYONECANPAY?r.push(o):e=!1,a===R.ALL)n=!1;else if(a===R.SINGLE)i.push(o);else if(a!==R.NONE)throw new Error(`Wrong signature hash output type: ${a}`)}return{addInput:e,addOutput:n,inputs:r,outputs:i}}get isFinal(){for(let e=0;e<this.inputs.length;e++)if(this.inputStatus(e)!=="finalized")return!1;return!0}get hasWitnesses(){let e=!1;for(const n of this.inputs)n.finalScriptWitness&&n.finalScriptWitness.length&&(e=!0);return e}get weight(){if(!this.isFinal)throw new Error("Transaction is not finalized");let e=32;const n=this.outputs.map(qt);this.hasWitnesses&&(e+=2),e+=4*gt.encode(this.inputs.length).length,e+=4*gt.encode(this.outputs.length).length;for(const r of this.inputs)e+=160+4*pt.encode(r.finalScriptSig||W).length;for(const r of n)e+=32+4*pt.encode(r.script).length;if(this.hasWitnesses)for(const r of this.inputs)r.finalScriptWitness&&(e+=$n.encode(r.finalScriptWitness).length);return e}get vsize(){return Math.ceil(this.weight/4)}toBytes(e=!1,n=!1){return mt.encode({version:this.version,lockTime:this.lockTime,inputs:this.inputs.map(ue).map(r=>({...r,finalScriptSig:e&&r.finalScriptSig||W})),outputs:this.outputs.map(qt),witnesses:this.inputs.map(r=>r.finalScriptWitness||[]),segwitFlag:n&&this.hasWitnesses})}get unsignedTx(){return this.toBytes(!1,!1)}get hex(){return P.encode(this.toBytes(!0,this.hasWitnesses))}get hash(){if(!this.isFinal)throw new Error("Transaction is not finalized");return P.encode(Bt(this.toBytes(!0)))}get id(){if(!this.isFinal)throw new Error("Transaction is not finalized");return P.encode(Bt(this.toBytes(!0)).reverse())}checkInputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.inputs.length)throw new Error(`Wrong input index=${e}`)}getInput(e){return this.checkInputIdx(e),xe(this.inputs[e])}get inputsLength(){return this.inputs.length}normalizeInput(e,n,r){let{nonWitnessUtxo:i,txid:o}=e;typeof i=="string"&&(i=P.decode(i)),H(i)&&(i=mt.decode(i)),i===void 0&&(i=n?.nonWitnessUtxo),typeof o=="string"&&(o=P.decode(o)),o===void 0&&(o=n?.txid);let s={...n,...e,nonWitnessUtxo:i,txid:o};s.nonWitnessUtxo===void 0&&delete s.nonWitnessUtxo,s.sequence===void 0&&(s.sequence=Qr),s.tapMerkleRoot===null&&delete s.tapMerkleRoot,s=Oe(Ae,s,n,r),Cn.encode(s);let c;return s.nonWitnessUtxo&&s.index!==void 0?c=s.nonWitnessUtxo.outputs[s.index]:s.witnessUtxo&&(c=s.witnessUtxo),c&&!this.opts.disableScriptCheck&&cr(c&&c.script,s.redeemScript,s.witnessScript),s}addInput(e,n=!1){if(!n&&!this.signStatus().addInput)throw new Error("Tx has signed inputs, cannot add new one");return this.inputs.push(this.normalizeInput(e)),this.inputs.length-1}updateInput(e,n,r=!1){this.checkInputIdx(e);let i;if(!r){const o=this.signStatus();(!o.addInput||o.inputs.includes(e))&&(i=Xo)}this.inputs[e]=this.normalizeInput(n,this.inputs[e],i)}checkOutputIdx(e){if(!Number.isSafeInteger(e)||0>e||e>=this.outputs.length)throw new Error(`Wrong output index=${e}`)}getOutput(e){return this.checkOutputIdx(e),xe(this.outputs[e])}get outputsLength(){return this.outputs.length}normalizeOutput(e,n,r){let{amount:i,script:o}=e;if(i===void 0&&(i=n?.amount),typeof i!="bigint")throw new Error("amount must be bigint sats");typeof o=="string"&&(o=P.decode(o)),o===void 0&&(o=n?.script);let s={...n,...e,amount:i,script:o};if(s.amount===void 0&&delete s.amount,s=Oe(ke,s,n,r),Rn.encode(s),s.script&&!this.opts.allowUnknownOutputs&&Q.decode(s.script).type==="unknown")throw new Error("Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownScript=true, if you sure");return this.opts.disableScriptCheck||cr(s.script,s.redeemScript,s.witnessScript),s}addOutput(e,n=!1){if(!n&&!this.signStatus().addOutput)throw new Error("Tx has signed outputs, cannot add new one");return this.outputs.push(this.normalizeOutput(e)),this.outputs.length-1}updateOutput(e,n,r=!1){this.checkOutputIdx(e);let i;if(!r){const o=this.signStatus();(!o.addOutput||o.outputs.includes(e))&&(i=Jo)}this.outputs[e]=this.normalizeOutput(n,this.outputs[e],i)}addOutputAddress(e,n,r=Kt){return this.addOutput({script:Q.encode(Pe(r).decode(e)),amount:n})}get fee(){let e=0n;for(const r of this.inputs){const i=this.prevOut(r);if(!i)throw new Error("Empty input amount");e+=i.amount}const n=this.outputs.map(qt);for(const r of n)e-=r.amount;return e}preimageLegacy(e,n,r){const{isAny:i,isNone:o,isSingle:s}=hr(r);if(e<0||!Number.isSafeInteger(e))throw new Error(`Invalid input idx=${e}`);if(s&&e>=this.outputs.length||e>=this.inputs.length)return $o.encode(1n);n=j.encode(j.decode(n).filter(l=>l!=="CODESEPARATOR"));let c=this.inputs.map(ue).map((l,u)=>({...l,finalScriptSig:u===e?n:W}));i?c=[c[e]]:(o||s)&&(c=c.map((l,u)=>({...l,sequence:u===e?l.sequence:0})));let a=this.outputs.map(qt);o?a=[]:s&&(a=a.slice(0,e).fill(qo).concat([a[e]]));const f=mt.encode({lockTime:this.lockTime,version:this.version,segwitFlag:!1,inputs:c,outputs:a});return Bt(f,te.encode(r))}preimageWitnessV0(e,n,r,i){const{isAny:o,isNone:s,isSingle:c}=hr(r);let a=le,f=le,l=le;const u=this.inputs.map(ue),d=this.outputs.map(qt);o||(a=Bt(...u.map(je.encode))),!o&&!c&&!s&&(f=Bt(...u.map(y=>N.encode(y.sequence)))),!c&&!s?l=Bt(...d.map(Mt.encode)):c&&e<d.length&&(l=Bt(Mt.encode(d[e])));const p=u[e];return Bt(te.encode(this.version),a,f,D(32,!0).encode(p.txid),N.encode(p.index),pt.encode(n),he.encode(i),N.encode(p.sequence),l,N.encode(this.lockTime),N.encode(r))}preimageWitnessV1(e,n,r,i,o=-1,s,c=192,a){if(!Array.isArray(i)||this.inputs.length!==i.length)throw new Error(`Invalid amounts array=${i}`);if(!Array.isArray(n)||this.inputs.length!==n.length)throw new Error(`Invalid prevOutScript array=${n}`);const f=[Lt.encode(0),Lt.encode(r),te.encode(this.version),N.encode(this.lockTime)],l=r===R.DEFAULT?R.ALL:r&3,u=r&R.ANYONECANPAY,d=this.inputs.map(ue),p=this.outputs.map(qt);u!==R.ANYONECANPAY&&f.push(...[d.map(je.encode),i.map(he.encode),n.map(pt.encode),d.map(h=>N.encode(h.sequence))].map(h=>et(Ut(...h)))),l===R.ALL&&f.push(et(Ut(...p.map(Mt.encode))));const y=(a?1:0)|(s?2:0);if(f.push(new Uint8Array([y])),u===R.ANYONECANPAY){const h=d[e];f.push(je.encode(h),he.encode(i[e]),pt.encode(n[e]),N.encode(h.sequence))}else f.push(N.encode(e));return y&1&&f.push(et(pt.encode(a||W))),l===R.SINGLE&&f.push(e<p.length?et(Mt.encode(p[e])):le),s&&f.push(de(s,c),Lt.encode(0),te.encode(o)),ft.utils.taggedHash("TapSighash",...f)}prevOut(e){if(e.nonWitnessUtxo){if(e.index===void 0)throw new Error("Unknown input index");return e.nonWitnessUtxo.outputs[e.index]}else{if(e.witnessUtxo)return e.witnessUtxo;throw new Error("Cannot find previous output info")}}inputType(e){let n="legacy",r=R.ALL;const i=this.prevOut(e),o=Q.decode(i.script);let s=o.type,c=o;const a=[o];if(o.type==="tr")return r=R.DEFAULT,{txType:"taproot",type:"tr",last:o,lastScript:i.script,defaultSighash:r,sighash:e.sighashType||r};{if((o.type==="wpkh"||o.type==="wsh")&&(n="segwit"),o.type==="sh"){if(!e.redeemScript)throw new Error("inputType: sh without redeemScript");let d=Q.decode(e.redeemScript);(d.type==="wpkh"||d.type==="wsh")&&(n="segwit"),a.push(d),c=d,s+=`-${d.type}`}if(c.type==="wsh"){if(!e.witnessScript)throw new Error("inputType: wsh without witnessScript");let d=Q.decode(e.witnessScript);d.type==="wsh"&&(n="segwit"),a.push(d),c=d,s+=`-${d.type}`}const f=a[a.length-1];if(f.type==="sh"||f.type==="wsh")throw new Error("inputType: sh/wsh cannot be terminal type");const l=Q.encode(f),u={type:s,txType:n,last:f,lastScript:l,defaultSighash:r,sighash:e.sighashType||r};if(n==="legacy"&&!this.opts.allowLegacyWitnessUtxo&&!e.nonWitnessUtxo)throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");return u}}signIdx(e,n,r,i){this.checkInputIdx(n);const o=this.inputs[n],s=this.inputType(o);if(!H(e)){if(!o.bip32Derivation||!o.bip32Derivation.length)throw new Error("bip32Derivation: empty");const l=o.bip32Derivation.filter(d=>d[1].fingerprint==e.fingerprint).map(([d,{path:p}])=>{let y=e;for(const h of p)y=y.deriveChild(h);if(!_(y.publicKey,d))throw new Error("bip32Derivation: wrong pubKey");if(!y.privateKey)throw new Error("bip32Derivation: no privateKey");return y});if(!l.length)throw new Error(`bip32Derivation: no items with fingerprint=${e.fingerprint}`);let u=!1;for(const d of l)this.signIdx(d.privateKey,n)&&(u=!0);return u}r?r.forEach(ms):r=[s.defaultSighash];const c=s.sighash;if(!r.includes(c))throw new Error(`Input with not allowed sigHash=${c}. Allowed: ${r.join(", ")}`);const{sigOutputs:a}=this.inputSighash(n);if(a===R.SINGLE&&n>=this.outputs.length)throw new Error(`Input with sighash SINGLE, but there is no output with corresponding index=${n}`);const f=this.prevOut(o);if(s.txType==="taproot"){if(o.tapBip32Derivation)throw new Error("tapBip32Derivation unsupported");const l=this.inputs.map(this.prevOut),u=l.map(g=>g.script),d=l.map(g=>g.amount);let p=!1,y=ft.getPublicKey(e),h=o.tapMerkleRoot||W;if(o.tapInternalKey){const{pubKey:g,privKey:w}=Es(e,y,o.tapInternalKey,h),[m,E]=Zr(o.tapInternalKey,h);if(_(m,g)){const A=this.preimageWitnessV1(n,u,c,d),v=Ut(ft.sign(A,w,i),c!==R.DEFAULT?new Uint8Array([c]):W);this.updateInput(n,{tapKeySig:v},!0),p=!0}}if(o.tapLeafScript){o.tapScriptSig=o.tapScriptSig||[];for(const[g,w]of o.tapLeafScript){const m=w.subarray(0,-1),E=j.decode(m),A=w[w.length-1],v=de(m,A);if(E.findIndex(X=>H(X)&&_(X,y))===-1)continue;const k=this.preimageWitnessV1(n,u,c,d,void 0,m,A),I=Ut(ft.sign(k,e,i),c!==R.DEFAULT?new Uint8Array([c]):W);this.updateInput(n,{tapScriptSig:[[{pubKey:y,leafHash:v},I]]},!0),p=!0}}if(!p)throw new Error("No taproot scripts signed");return!0}else{const l=Gr(e);let u=!1;const d=He(l);for(const h of j.decode(s.lastScript))H(h)&&(_(h,l)||_(h,d))&&(u=!0);if(!u)throw new Error(`Input script doesn't have pubKey: ${s.lastScript}`);let p;if(s.txType==="legacy")p=this.preimageLegacy(n,s.lastScript,c);else if(s.txType==="segwit"){let h=s.lastScript;s.last.type==="wpkh"&&(h=Q.encode({type:"pkh",hash:s.last.hash})),p=this.preimageWitnessV0(n,h,c,f.amount)}else throw new Error(`Transaction/sign: unknown tx type: ${s.txType}`);const y=Wo(p,e,this.opts.lowR);this.updateInput(n,{partialSig:[[l,Ut(y,new Uint8Array([c]))]]},!0)}return!0}sign(e,n,r){let i=0;for(let o=0;o<this.inputs.length;o++)try{this.signIdx(e,o,n,r)&&i++}catch{}if(!i)throw new Error("No inputs signed");return i}finalizeIdx(e){if(this.checkInputIdx(e),this.fee<0n)throw new Error("Outputs spends more than inputs amount");const n=this.inputs[e],r=this.inputType(n);if(r.txType==="taproot"){if(n.tapKeySig)n.finalScriptWitness=[n.tapKeySig];else if(n.tapLeafScript&&n.tapScriptSig){const a=n.tapLeafScript.sort((f,l)=>Yt.encode(f[0]).length-Yt.encode(l[0]).length);for(const[f,l]of a){const u=l.slice(0,-1),d=l[l.length-1],p=Q.decode(u),y=de(u,d),h=n.tapScriptSig.filter(w=>_(w[0].leafHash,y));let g=[];if(p.type==="tr_ms"){const w=p.m,m=p.pubkeys;let E=0;for(const A of m){const v=h.findIndex(x=>_(x[0].pubKey,A));if(E===w||v===-1){g.push(W);continue}g.push(h[v][1]),E++}if(E!==w)continue}else if(p.type==="tr_ns"){for(const w of p.pubkeys){const m=h.findIndex(E=>_(E[0].pubKey,w));m!==-1&&g.push(h[m][1])}if(g.length!==p.pubkeys.length)continue}else if(p.type==="unknown"&&this.opts.allowUnknownInputs){const w=j.decode(u);if(g=h.map(([{pubKey:m},E])=>{const A=w.findIndex(v=>H(v)&&_(v,m));if(A===-1)throw new Error("finalize/taproot: cannot find position of pubkey in script");return{signature:E,pos:A}}).sort((m,E)=>m.pos-E.pos).map(m=>m.signature),!g.length)continue}else throw new Error("Finalize: Unknown tapLeafScript");n.finalScriptWitness=g.reverse().concat([u,Yt.encode(f)]);break}if(!n.finalScriptWitness)throw new Error("finalize/taproot: empty witness")}else throw new Error("finalize/taproot: unknown input");n.finalScriptSig=W,dr(n);return}if(!n.partialSig||!n.partialSig.length)throw new Error("Not enough partial sign");let i=W,o=[];if(r.last.type==="ms"){const a=r.last.m,f=r.last.pubkeys;let l=[];for(const u of f){const d=n.partialSig.find(p=>_(u,p[0]));d&&l.push(d[1])}if(l=l.slice(0,a),l.length!==a)throw new Error(`Multisig: wrong signatures count, m=${a} n=${f.length} signatures=${l.length}`);i=j.encode([0,...l])}else if(r.last.type==="pk")i=j.encode([n.partialSig[0][1]]);else if(r.last.type==="pkh")i=j.encode([n.partialSig[0][1],n.partialSig[0][0]]);else if(r.last.type==="wpkh")i=W,o=[n.partialSig[0][1],n.partialSig[0][0]];else if(r.last.type==="unknown"&&!this.opts.allowUnknownInputs)throw new Error("Unknown inputs not allowed");let s,c;if(r.type.includes("wsh-")&&(i.length&&r.lastScript.length&&(o=j.decode(i).map(a=>{if(a===0)return W;if(H(a))return a;throw new Error(`Wrong witness op=${a}`)})),o=o.concat(r.lastScript)),r.txType==="segwit"&&(c=o),r.type.startsWith("sh-wsh-")?s=j.encode([j.encode([0,et(r.lastScript)])]):r.type.startsWith("sh-")?s=j.encode([...j.decode(i),r.lastScript]):r.type.startsWith("wsh-")||r.txType!=="segwit"&&(s=i),!s&&!c)throw new Error("Unknown error finalizing input");s&&(n.finalScriptSig=s),c&&(n.finalScriptWitness=c),dr(n)}finalize(){for(let e=0;e<this.inputs.length;e++)this.finalizeIdx(e)}extract(){if(!this.isFinal)throw new Error("Transaction has unfinalized inputs");if(!this.outputs.length)throw new Error("Transaction has no outputs");if(this.fee<0n)throw new Error("Outputs spends more than inputs amount");return this.toBytes(!0,!0)}combine(e){for(const i of["PSBTVersion","version","lockTime"])if(this.opts[i]!==e.opts[i])throw new Error(`Transaction/combine: different ${i} this=${this.opts[i]} other=${e.opts[i]}`);for(const i of["inputs","outputs"])if(this[i].length!==e[i].length)throw new Error(`Transaction/combine: different ${i} length this=${this[i].length} other=${e[i].length}`);const n=this.global.unsignedTx?mt.encode(this.global.unsignedTx):W,r=e.global.unsignedTx?mt.encode(e.global.unsignedTx):W;if(!_(n,r))throw new Error("Transaction/combine: different unsigned tx");this.global=Oe(Nn,this.global,e.global);for(let i=0;i<this.inputs.length;i++)this.updateInput(i,e.inputs[i],!0);for(let i=0;i<this.outputs.length;i++)this.updateOutput(i,e.outputs[i],!0);return this}clone(){return ne.fromPSBT(this.toPSBT(2),this.opts)}}function $s(t,e,n=Kt){if(t==="tr")return ds(ft.getPublicKey(e),void 0,n).address;const r=Gr(e);if(t==="pkh")return is(r,n).address;if(t==="wpkh")return as(r,n).address;throw new Error(`getAddress: unknown type=${t}`)}export{Ts as N,Us as T,Is as a,Kt as b,As as c,ks as d,$s as g};
